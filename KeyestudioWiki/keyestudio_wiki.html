<!DOCTYPE html>
<!-- saved from url=(0111)https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_10:_Photo_Resistor -->
<html class="client-js" lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Ks0077(78, 79) keyestudio Super Learning Kit for Arduino - Keyestudio Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino","wgTitle":"Ks0077(78, 79) keyestudio Super Learning Kit for Arduino","wgCurRevisionId":15016,"wgRevisionId":15016,"wgArticleId":3154,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Starter Kit"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino","wgRelevantArticleId":3154,"wgRequestId":"7deb281fe1d2398651655409","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgWikiEditorEnabledModules":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","site":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@0qn2kg0",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="./keyestudio_wiki_files/load.php">
<script async="" src="./keyestudio_wiki_files/load(1).php"></script>
<style>
@media screen {
	.tochidden,.toctoggle{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.toctoggle{font-size:94%}}
@media print {
	.toc.tochidden,.toctoggle{display:none}}
.suggestions{overflow:hidden;position:absolute;top:0;left:0;width:0;border:0;z-index:1099;padding:0;margin:-1px 0 0 0}.suggestions-special{position:relative;background-color:#fff;cursor:pointer;border:1px solid #a2a9b1;margin:0;margin-top:-2px;display:none;padding:0.25em 0.25em;line-height:1.25em}.suggestions-results{background-color:#fff;cursor:pointer;border:1px solid #a2a9b1;padding:0;margin:0}.suggestions-result{color:#000;margin:0;line-height:1.5em;padding:0.01em 0.25em;text-align:left; overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.suggestions-result-current{background-color:#2a4b8d;color:#fff}.suggestions-special .special-label{color:#72777d;text-align:left}.suggestions-special .special-query{color:#000;font-style:italic;text-align:left}.suggestions-special .special-hover{background-color:#c8ccd1}.suggestions-result-current .special-label,.suggestions-result-current .special-query{color:#fff}.highlight{font-weight:bold}</style><style>
.suggestions a.mw-searchSuggest-link,.suggestions a.mw-searchSuggest-link:hover,.suggestions a.mw-searchSuggest-link:active,.suggestions a.mw-searchSuggest-link:focus{color:#000;text-decoration:none}.suggestions-result-current a.mw-searchSuggest-link,.suggestions-result-current a.mw-searchSuggest-link:hover,.suggestions-result-current a.mw-searchSuggest-link:active,.suggestions-result-current a.mw-searchSuggest-link:focus{color:#fff}.suggestions a.mw-searchSuggest-link .special-query{ overflow:hidden;text-overflow:ellipsis;white-space:nowrap}</style><meta name="ResourceLoaderDynamicStyles" content="">
<meta name="generator" content="MediaWiki 1.31.1">
<link rel="shortcut icon" href="https://wiki.keyestudio.com/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="https://wiki.keyestudio.com/opensearch_desc.php" title="Keyestudio Wiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.keyestudio.com/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="Keyestudio Wiki Atom feed" href="https://wiki.keyestudio.com/index.php?title=Special:RecentChanges&amp;feed=atom">
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=vector&amp;sync=1"></script><![endif]-->
<script src="./keyestudio_wiki_files/load(2).php"></script></head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Ks0077_78_79_keyestudio_Super_Learning_Kit_for_Arduino rootpage-Ks0077_78_79_keyestudio_Super_Learning_Kit_for_Arduino skin-vector action-view"> <div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
<a id="top"></a>
<div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Ks0077(78, 79) keyestudio Super Learning Kit for Arduino</h1>
<div id="bodyContent" class="mw-body-content">
<div id="siteSub">From Keyestudio Wiki</div>
<div id="contentSub"></div>
<div id="jump-to-nav" class="mw-jump">
Jump to: <a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#mw-head">navigation</a>, <a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#p-search">search</a>
</div>
<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a role="button" tabindex="0" class="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#keyestudio_Super_Learning_Kit_for_Arduino"><span class="tocnumber">1</span> <span class="toctext"><b>keyestudio Super Learning Kit for Arduino</b></span></a></li>
<li class="toclevel-1 tocsection-2"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Kit_Introduction"><span class="tocnumber">2</span> <span class="toctext"><b>Kit Introduction</b></span></a></li>
<li class="toclevel-1 tocsection-3"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Kit_Contents"><span class="tocnumber">3</span> <span class="toctext"><b>Kit Contents</b></span></a></li>
<li class="toclevel-1 tocsection-4"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_List"><span class="tocnumber">4</span> <span class="toctext"><b>Project List</b></span></a></li>
<li class="toclevel-1 tocsection-5"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_Details"><span class="tocnumber">5</span> <span class="toctext"><b>Project Details</b></span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_1:_Hello_World"><span class="tocnumber">5.1</span> <span class="toctext"><b>Project 1: Hello World</b></span></a></li>
<li class="toclevel-2 tocsection-7"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_2:_LED_Blinking"><span class="tocnumber">5.2</span> <span class="toctext"><b>Project 2: LED Blinking</b></span></a></li>
<li class="toclevel-2 tocsection-8"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_3:_PWM"><span class="tocnumber">5.3</span> <span class="toctext"><b>Project 3: PWM</b></span></a></li>
<li class="toclevel-2 tocsection-9"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_4:_Traffic_Light"><span class="tocnumber">5.4</span> <span class="toctext"><b>Project 4: Traffic Light</b></span></a></li>
<li class="toclevel-2 tocsection-10"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_5:_LED_Chasing_Effect"><span class="tocnumber">5.5</span> <span class="toctext"><b>Project 5: LED Chasing Effect</b></span></a></li>
<li class="toclevel-2 tocsection-11"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_6:_Button-controlled_LED"><span class="tocnumber">5.6</span> <span class="toctext"><b>Project 6: Button-controlled LED</b></span></a></li>
<li class="toclevel-2 tocsection-12"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_7:_Active_Buzzer"><span class="tocnumber">5.7</span> <span class="toctext"><b>Project 7: Active Buzzer</b></span></a></li>
<li class="toclevel-2 tocsection-13"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_8:_Passive_Buzzer"><span class="tocnumber">5.8</span> <span class="toctext"><b>Project 8: Passive Buzzer</b></span></a></li>
<li class="toclevel-2 tocsection-14"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_9:_RGB_LED"><span class="tocnumber">5.9</span> <span class="toctext"><b>Project 9: RGB LED</b></span></a></li>
<li class="toclevel-2 tocsection-15"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_10:_Photo_Resistor"><span class="tocnumber">5.10</span> <span class="toctext"><b>Project 10: Photo Resistor</b></span></a></li>
<li class="toclevel-2 tocsection-16"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_11:_Flame_Sensor"><span class="tocnumber">5.11</span> <span class="toctext"><b>Project 11: Flame Sensor</b></span></a></li>
<li class="toclevel-2 tocsection-17"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_12:_LM35_Temperature_Sensor"><span class="tocnumber">5.12</span> <span class="toctext"><b>Project 12: LM35 Temperature Sensor</b></span></a></li>
<li class="toclevel-2 tocsection-18"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_13:_Tilt_Switch"><span class="tocnumber">5.13</span> <span class="toctext"><b>Project 13: Tilt Switch</b></span></a></li>
<li class="toclevel-2 tocsection-19"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_14:_IR_Remote_Control"><span class="tocnumber">5.14</span> <span class="toctext"><b>Project 14: IR Remote Control</b></span></a></li>
<li class="toclevel-2 tocsection-20"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_15:_Analog_Value_Reading"><span class="tocnumber">5.15</span> <span class="toctext"><b>Project 15: Analog Value Reading</b></span></a></li>
<li class="toclevel-2 tocsection-21"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_16:_74HC595"><span class="tocnumber">5.16</span> <span class="toctext"><b>Project 16: 74HC595</b></span></a></li>
<li class="toclevel-2 tocsection-22"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_17:_1-digit_LED_Segment_Display"><span class="tocnumber">5.17</span> <span class="toctext"><b>Project 17: 1-digit LED Segment Display</b></span></a></li>
<li class="toclevel-2 tocsection-23"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_18:_4-digit_LED_Segment_Display"><span class="tocnumber">5.18</span> <span class="toctext"><b>Project 18: 4-digit LED Segment Display</b></span></a></li>
<li class="toclevel-2 tocsection-24"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_19:_8.2A8_LED_Matrix"><span class="tocnumber">5.19</span> <span class="toctext"><b>Project 19: 8*8 LED Matrix</b></span></a></li>
<li class="toclevel-2 tocsection-25"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_20:_1602_LCD"><span class="tocnumber">5.20</span> <span class="toctext"><b>Project 20: 1602 LCD</b></span></a></li>
<li class="toclevel-2 tocsection-26"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_21:_9g_Servo_Control"><span class="tocnumber">5.21</span> <span class="toctext"><b>Project 21: 9g Servo Control</b></span></a></li>
<li class="toclevel-2 tocsection-27"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_22:_5V_Stepper_Motor"><span class="tocnumber">5.22</span> <span class="toctext"><b>Project 22: 5V Stepper Motor</b></span></a></li>
<li class="toclevel-2 tocsection-28"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_23:_PIR_Motion_Sensor"><span class="tocnumber">5.23</span> <span class="toctext"><b>Project 23: PIR Motion Sensor</b></span></a></li>
<li class="toclevel-2 tocsection-29"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_24:_Analog_Gas_Sensor"><span class="tocnumber">5.24</span> <span class="toctext"><b>Project 24: Analog Gas Sensor</b></span></a></li>
<li class="toclevel-2 tocsection-30"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_25:_ADXL345_Three_Axis_Acceleration_Module"><span class="tocnumber">5.25</span> <span class="toctext"><b>Project 25: ADXL345 Three Axis Acceleration Module</b></span></a></li>
<li class="toclevel-2 tocsection-31"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_26:_HC-SR04_Ultrasonic_Sensor"><span class="tocnumber">5.26</span> <span class="toctext"><b>Project 26: HC-SR04 Ultrasonic Sensor</b></span></a></li>
<li class="toclevel-2 tocsection-32"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_27:_Joystick_Module"><span class="tocnumber">5.27</span> <span class="toctext"><b>Project 27: Joystick Module</b></span></a></li>
<li class="toclevel-2 tocsection-33"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_28:_5V_Relay_Module"><span class="tocnumber">5.28</span> <span class="toctext"><b>Project 28: 5V Relay Module </b></span></a></li>
<li class="toclevel-2 tocsection-34"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_29:_DS3231_Clock_Module"><span class="tocnumber">5.29</span> <span class="toctext"><b>Project 29: DS3231 Clock Module </b></span></a></li>
<li class="toclevel-2 tocsection-35"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_30:_DHT11_Temperature_and_Humidity_Sensor"><span class="tocnumber">5.30</span> <span class="toctext"><b>Project 30: DHT11 Temperature and Humidity Sensor </b></span></a></li>
<li class="toclevel-2 tocsection-36"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_31:_Soil_Humidity_Sensor"><span class="tocnumber">5.31</span> <span class="toctext"><b>Project 31: Soil Humidity Sensor </b></span></a></li>
<li class="toclevel-2 tocsection-37"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Project_32:_RC522_RFID_Module"><span class="tocnumber">5.32</span> <span class="toctext"><b>Project 32: RC522 RFID Module </b></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-38"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Resources"><span class="tocnumber">6</span> <span class="toctext"><b>Resources</b></span></a></li>
<li class="toclevel-1 tocsection-39"><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#Buy_From"><span class="tocnumber">7</span> <span class="toctext"><b>Buy From</b></span></a></li>
</ul>
</div>
<h2><span class="mw-headline" id="keyestudio_Super_Learning_Kit_for_Arduino"><b>keyestudio Super Learning Kit for Arduino</b></span></h2>
<p><br><a href="https://wiki.keyestudio.com/File:KS0077.jpg" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-KS0077.jpg" width="500" height="500" srcset="/images/thumb/c/ca/KS0077.jpg/750px-KS0077.jpg 1.5x, /images/c/ca/KS0077.jpg 2x"></a><br>
</p>
<h2><span class="mw-headline" id="Kit_Introduction"><b>Kit Introduction</b></span></h2>
<p>Keyestudio super learning kit is suitable for Arduino enthusiasts. This kit includes 32 projects with detailed tutorials, starting from the basics to more complex projects. Differ from other kits, it adds some functional modules, such as RFID, temperature and humidity module. There is connection diagram and code for each project, making it easy for you to learn.
</p>
<h2><span class="mw-headline" id="Kit_Contents"><b>Kit Contents</b></span></h2>
<table width="80%" cellspacing="0" border="1">
<tbody><tr>
<th align="center" scope="col">No.
</th>
<th align="center" scope="col">Product Name
</th>
<th align="center" scope="col">Quantity
</th>
<th align="center" scope="col">Picture
</th></tr>
<tr>
<td align="center">1
</td>
<td align="center">NO Board with KS0077 Kit
</td>
<td align="center">1
</td>
<td align="center">
</td></tr>
<tr>
<td align="center">1
</td>
<td align="center">UNO R3 with KS0078 Kit
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:772.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/772.png" width="186" height="130"></a><br>
</td></tr>
<tr>
<td align="center">1
</td>
<td align="center">256O R3 with KS0079 Kit
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:771.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/771.png" width="231" height="119"></a><br>
</td></tr>
<tr>
<td align="center">1
</td>
<td align="center">LED - Blue
</td>
<td align="center">5
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:761.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/761.png" width="111" height="101"></a><br>
</td></tr>
<tr>
<td align="center">2
</td>
<td align="center">LED - Red
</td>
<td align="center">5
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:762.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/762.png" width="117" height="101"></a><br>
</td></tr>
<tr>
<td align="center">3
</td>
<td align="center">LED - Yellow
</td>
<td align="center">5
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:763.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/763.png" width="109" height="99"></a><br>
</td></tr>
<tr>
<td align="center">4
</td>
<td align="center">LED - RGB
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:764.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/764.png" width="107" height="36"></a><br>
</td></tr>
<tr>
<td align="center">5
</td>
<td align="center">220 Ω resistor
</td>
<td align="center">8
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:765.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/765.png" width="78" height="67"></a><br>
</td></tr>
<tr>
<td align="center">6
</td>
<td align="center">10K Ω resistor
</td>
<td align="center">5
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:766.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/766.png" width="83" height="73"></a><br>
</td></tr>
<tr>
<td align="center">7
</td>
<td align="center">1K Ω resistor
</td>
<td align="center">5
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:767.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/767.png" width="103" height="90"></a><br>
</td></tr>
<tr>
<td align="center">8
</td>
<td align="center">103 Potentiometer
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:768.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/768.png" width="87" height="69"></a><br>
</td></tr>
<tr>
<td align="center">9
</td>
<td align="center">Buzzer (active)
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:769.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/769.png" width="74" height="69"></a><br>
</td></tr>
<tr>
<td align="center">10
</td>
<td align="center">Buzzer (passive)
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7610.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7610.png" width="67" height="78"></a><br>
</td></tr>
<tr>
<td align="center">11
</td>
<td align="center">Large button switch
</td>
<td align="center">4
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7611.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7611.png" width="191" height="54"></a><br>
</td></tr>
<tr>
<td align="center">12
</td>
<td align="center">Ball tilt sensor
</td>
<td align="center">2
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7612.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7612.png" width="79" height="70"></a><br>
</td></tr>
<tr>
<td align="center">13
</td>
<td align="center">Photo Resistor
</td>
<td align="center">3
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7613a.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7613a.png" width="44" height="36"></a><br><br><a href="https://wiki.keyestudio.com/File:7613b.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7613b.png" width="59" height="35"></a><br><br><a href="https://wiki.keyestudio.com/File:7613c.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7613c.png" width="54" height="32"></a><br>
</td></tr>
<tr>
<td align="center">14
</td>
<td align="center">Flame sensor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7614.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7614.png" width="80" height="44"></a><br>
</td></tr>
<tr>
<td align="center">15
</td>
<td align="center">LM35 Temp Sensor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7615.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7615.png" width="75" height="76"></a><br>
</td></tr>
<tr>
<td align="center">16
</td>
<td align="center">IC 74HC595N 16-pin DIP
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7616.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7616.png" width="96" height="70"></a><br>
</td></tr>
<tr>
<td align="center">17
</td>
<td align="center">1-digit LED module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7617.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7617.png" width="81" height="48"></a><br>
</td></tr>
<tr>
<td align="center">18
</td>
<td align="center">4-digit LED module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7618.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7618.png" width="81" height="68"></a><br>
</td></tr>
<tr>
<td align="center">19
</td>
<td align="center">8*8 LED Matrix
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7619.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7619.png" width="71" height="71"></a><br>
</td></tr>
<tr>
<td align="center">20
</td>
<td align="center">1602 LCD display
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7620.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7620.png" width="141" height="69"></a><br>
</td></tr>
<tr>
<td align="center">21
</td>
<td align="center">IR receiver
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7621.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7621.png" width="103" height="46"></a><br>
</td></tr>
<tr>
<td align="center">22
</td>
<td align="center">IR remote control
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7722.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7722.png" width="171" height="84"></a><br>
</td></tr>
<tr>
<td align="center">23
</td>
<td align="center">Servo Motor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7723.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7723.png" width="147" height="104"></a><br>
</td></tr>
<tr>
<td align="center">24
</td>
<td align="center">Stepper driver module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7724.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7724.png" width="141" height="107"></a><br>
</td></tr>
<tr>
<td align="center">25
</td>
<td align="center">Stepper Motor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7725.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7725.png" width="146" height="100"></a><br>
</td></tr>
<tr>
<td align="center">26
</td>
<td align="center">Joystick module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:Joystick-.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Joystick-.png" width="137" height="108"></a><br>
</td></tr>
<tr>
<td align="center">27
</td>
<td align="center">Relay module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:Relay.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/200px-Relay.png" width="200" height="162" srcset="/images/7/74/Relay.png 1.5x"></a><br>
</td></tr>
<tr>
<td align="center">28
</td>
<td align="center">PIR Motion Sensor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:PIR_motion.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/200px-PIR_motion.png" width="200" height="153" srcset="/images/thumb/e/e2/PIR_motion.png/300px-PIR_motion.png 1.5x, /images/e/e2/PIR_motion.png 2x"></a><br>
</td></tr>
<tr>
<td align="center">29
</td>
<td align="center">Analog Gas Sensor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:Analog_gas.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/200px-Analog_gas.png" width="200" height="119" srcset="/images/thumb/3/3d/Analog_gas.png/300px-Analog_gas.png 1.5x, /images/3/3d/Analog_gas.png 2x"></a><br>
</td></tr>
<tr>
<td align="center">30
</td>
<td align="center">ADXL345 Three Axis Acceleration Module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/200px-三轴加速.png" width="200" height="163" srcset="/images/thumb/f/fe/%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png/300px-%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png 1.5x, /images/thumb/f/fe/%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png/400px-%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png 2x"></a><br>
</td></tr>
<tr>
<td align="center">31
</td>
<td align="center">HC-SR04 Ultrasonic Sensor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7631.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7631.png" width="100" height="75"></a><br>
</td></tr>
<tr>
<td align="center">32
</td>
<td align="center">DS3231 Clock Module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:Clock.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/200px-Clock.png" width="200" height="160" srcset="/images/thumb/3/35/Clock.png/300px-Clock.png 1.5x, /images/3/35/Clock.png 2x"></a><br>
</td></tr>
<tr>
<td align="center">33
</td>
<td align="center">DHT11 Temperature &amp; Humidity Sensor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:DHT11.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/200px-DHT11.png" width="200" height="154" srcset="/images/thumb/8/85/DHT11.png/300px-DHT11.png 1.5x, /images/8/85/DHT11.png 2x"></a><br>
</td></tr>
<tr>
<td align="center">34
</td>
<td align="center">Soil humidity sensor
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:Soil.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/200px-Soil.png" width="200" height="137" srcset="/images/thumb/4/42/Soil.png/300px-Soil.png 1.5x, /images/4/42/Soil.png 2x"></a><br>
</td></tr>
<tr>
<td align="center">35
</td>
<td align="center">RC522 RFID module
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:KS0077-.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/KS0077-.png" width="238" height="158"></a><br>
</td></tr>
<tr>
<td align="center">36
</td>
<td align="center">RFID card
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7736.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7736.png" width="166" height="117"></a><br>
</td></tr>
<tr>
<td align="center">37
</td>
<td align="center">RFID key
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7737.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7737.png" width="228" height="117"></a><br>
</td></tr>
<tr>
<td align="center">38
</td>
<td align="center">Pin headers
</td>
<td align="center">40
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7632.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7632.png" width="224" height="40"></a><br>
</td></tr>
<tr>
<td align="center">39
</td>
<td align="center">830 hole Breadboard
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7633.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7633.png" width="130" height="65"></a><br>
</td></tr>
<tr>
<td align="center">40
</td>
<td align="center">Dupont connector wires
</td>
<td align="center">10
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7740.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7740.png" width="229" height="63"></a><br>
</td></tr>
<tr>
<td align="center">41
</td>
<td align="center">Jumper Wire
</td>
<td align="center">30
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7635.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7635.png" width="146" height="80"></a><br>
</td></tr>
<tr>
<td align="center">42
</td>
<td align="center">6-cell AA Battery pack
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7636.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7636.png" width="110" height="89"></a><br>
</td></tr>
<tr>
<td align="center">43
</td>
<td align="center">USB cable
</td>
<td align="center">1
</td>
<td align="center"><br><a href="https://wiki.keyestudio.com/File:7637.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/7637.png" width="104" height="62"></a><br>
</td></tr>
</tbody></table>
<h2><span class="mw-headline" id="Project_List"><b>Project List</b></span></h2>
<ul><li>1.Hello World <br></li>
<li>2.LED Blinking<br></li>
<li>3.PWM<br></li>
<li>4.Traffic Light<br></li>
<li>5.LED Chase Effect<br></li>
<li>6.Button-controlled LED<br></li>
<li>7.Active Buzzer<br></li>
<li>8.Passive Buzzer<br></li>
<li>9.RGB LED<br></li>
<li>10.Photo Resistor<br></li>
<li>11.Flame Sensor<br></li>
<li>12.LM35 Temperature Sensor<br></li>
<li>13.Tilt Switch<br></li>
<li>14.IR Remote Control<br></li>
<li>15.Analog Value Reading<br></li>
<li>16.74HC595<br></li>
<li>17.1-digit LED Segment Display<br></li>
<li>18.4-digit LED Segment Display<br></li>
<li>19.8*8 LED Matrix<br></li>
<li>20.1602 LCD<br></li>
<li>21.9g Servo Control<br></li>
<li>22.Stepper Motor<br></li>
<li>23.PIR Motion Sensor<br></li>
<li>24.Analog Gas Sensor<br></li>
<li>25.ADXL345 Three Axis Acceleration Module<br></li>
<li>26.HC-SR04 Ultrasonic Sensor<br></li>
<li>27.Joystick Module<br></li>
<li>28.5V Relay Module <br></li>
<li>29.DS3231 Clock Module<br></li>
<li>30.DHT11 Temperature and Humidity Sensor <br></li>
<li>31.Soil Humidity Sensor<br></li>
<li>32.RC522 RFID Module<br></li></ul>
<h2><span class="mw-headline" id="Project_Details"><b>Project Details</b></span></h2>
<h3><span class="mw-headline" id="Project_1:_Hello_World"><b>Project 1: Hello World</b></span></h3>
<p><b>Introduction:</b>
</p><p>As for starters, we will begin with something simple. In this project, you only need an Arduino and a USB cable to start the "Hello World!" experiment.This is not only a communication test of your Arduino and PC, but also a primer project for you to have your first try in the Arduino world!<br>
</p><p><b>Hardware Required:</b><br>
1. Arduino board x1<br>
2. USB cable x1<br>
</p><p><b>Sample Code:</b><br>
After installing driver for Arduino, let's open Arduino software and compile the code that enables Arduino to print"Hello World!" under your instruction. Of course, you can compile the code for Arduino to continuously echo "Hello World!" without instruction. A simple If () statement will do the instruction trick. With the onboard LED connected to pin 13, you can instruct the LED to blink first when Arduino gets an instruction and then print the character"Hello World!”.
</p>
<pre>int val;//define variable val
int ledpin=13;// define digital interface 13
void setup()
{
Serial.begin(9600);// set the baud rate at 9600 to match the software set up. When connected to a specific device, (e.g. bluetooth), the baud rate needs to be the same with it.
pinMode(ledpin,OUTPUT);// initialize digital pin 13 as output. When using I/O ports on an Arduino, this kind of set up is always needed.
}
void loop()
{
val=Serial.read();// read the instruction or character from PC to Arduino, and assign them to Val.
if(val=='R')// determine if the instruction or character received is “R”.
{  // if it’s “R”,    
digitalWrite(ledpin,HIGH);// set the LED on digital pin 13 on. 
delay(500);
digitalWrite(ledpin,LOW);// set the LED on digital pin 13 off.    
delay(500);
Serial.println("Hello World!");// display“Hello World！”string.
}
}
</pre>
<p><b>Result:</b><br>
<br><a href="https://wiki.keyestudio.com/File:693.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-693.png" width="500" height="591" srcset="/images/d/db/693.png 1.5x"></a><br>
</p><p>Click serial port monitor<br>
Input R<br>
LED 13 will blink once；<br>
PC will receive information from Arduino: Hello World<br>
</p><p><br><a href="https://wiki.keyestudio.com/File:1%EF%BC%881%EF%BC%89.jpg" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/1（1）.jpg" width="435" height="406"></a><br>
</p><p>After choosing the right port, the experiment is very easy for you!
</p>
<h3><span class="mw-headline" id="Project_2:_LED_Blinking"><b>Project 2: LED Blinking</b></span></h3>
<p><b>Introduction:</b>
</p><p>Blinking LED experiment is quite simple. In the "Hello World!" program, we have come across LED. This time, we are going to connect an LED to one of the digital pins rather than using LED13 which is soldered to the board. Apart from an Arduino and a USB cable, you will need extra parts as below:<br>
</p><p><b>Hardware Required:</b><br>
1. Red M5 LED*1 <br>
2. 220Ω resistor*1<br>
3. Breadboard*1<br>
4. Breadboard jumper wires* several <br>
</p><p>We follow below diagram from the experimental schematic link. Here we use digital pin 10. Connect an LED to a 220 ohm resistor to avoid high current damaging the LED.
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:695.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/695.png" width="374" height="471"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:696.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/696.png" width="369" height="348"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>int ledPin = 10; // define digital pin 10.
void setup()
{
pinMode(ledPin, OUTPUT);// define pin with LED connected as output.
}
void loop()
{
digitalWrite(ledPin, HIGH); // set the LED on.
delay(1000); // wait for a second.
digitalWrite(ledPin, LOW); // set the LED off.
delay(1000); // wait for a second
}
</pre>
<p><b>Result:</b><br>
After downloading this program, in the experiment, you will see the LED connected to pin 10 turning on and off, with an interval approximately one second.
The blinking LED experiment is now completed. Thank you!
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_3:_PWM"><b>Project 3: PWM</b></span></h3>
<p><b>Introduction:</b>
</p><p>PWM, short for Pulse Width Modulation, is a technique used to encode analog signal level into digital ones. A computer cannot output analog voltage but only digital voltage values such as 0V or 5V. So we use a high resolution counter to encode a specific analog signal level by modulating the duty cycle of PMW. The PWM signal is also digitalized because in any given moment, fully on DC power supply is either 5V (ON), or 0V (OFF). The voltage or current is fed to the analog load (the device that uses the power) by repeated pulse sequence being ON or OFF. Being on, the current is fed to the load; being off, it's not. With adequate bandwidth, any analog value can be encoded using PWM. The output voltage value is calculated via the on and off time. <br>
Output voltage = (turn on time/pulse time) * maximum voltage value <br>
<br><a href="https://wiki.keyestudio.com/File:697.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/697.png" width="483" height="302"></a><br>
</p><p>PWM has many applications: <br>
lamp brightness regulating, motor speed regulating, sound making, etc. <br>
The following are the three basic parameters of PMW:
<br><a href="https://wiki.keyestudio.com/File:698.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/698.png" width="431" height="194"></a><br>
1. The amplitude of pulse width (minimum / maximum)<br>
2. The pulse period (The reciprocal of pulse frequency in 1 second)<br>
3. The voltage level（such as：0V-5V）<br>
There are 6 PMW interfaces on Arduino, namely digital pin 3, 5, 6, 9, 10, and 11. In previous experiments, we have done "button-controlled LED", using digital signal to control digital pin. This time, we will use a potentiometer to control the brightness of LED.<br>
</p><p><b>Hardware Required:</b><br>
1. Potentiometer*1 <br>
2. Red M5 LED*1<br>
3. 220Ω resistor<br>
4. Breadboard*1 <br>
5. Breadboard jumper wires*several<br>
</p><p>The input of potentiometer is analog, so we connect it to analog port, and LED to PWM port. Different PWM signal can regulate the brightness of the LED.<br>
<b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:699.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/699.png" width="330" height="460"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6910.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6910.png" width="432" height="412"></a><br>
</p><p><b>Sample Code:</b><br>
In the program compiling process, we will use the analogWrite (PWM interface, analog value) function. In this experiment, we will read the analog value of the potentiometer and assign the value to PWM port, so there will be corresponding change to the brightness of the LED. One final part will display the analog value on the screen. You can consider this as the "analog value reading" project adding the PWM analog value assigning part. Below is a sample program for your reference.
</p>
<pre>int potpin=0;// initialize analog pin 0
int ledpin=11;//initialize digital pin 11（PWM output）
int val=0;// Temporarily store variables' value from the sensor
void setup()
{
pinMode(ledpin,OUTPUT);// define digital pin 11 as “output”
Serial.begin(9600);// set baud rate at 9600
// attention: for analog ports, they are automatically set up as “input”
}
void loop()
{

val=analogRead(potpin);// read the analog value from the sensor and assign it to val
Serial.println(val);// display value of val
analogWrite(ledpin,val/4);// turn on LED and set up brightness（maximum output of PWM is 255）
delay(10);// wait for 0.01 second
}
</pre>
<p><br><a href="https://wiki.keyestudio.com/File:6911.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6911.png" width="499" height="599"></a><br>
</p><p><b>Result:</b><br>
After uploading the program, when you rotate the potentiometer knob, you can see the value change, and also obvious change of the LED brightness.
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_4:_Traffic_Light"><b>Project 4: Traffic Light</b></span></h3>
<p><b>Introduction:</b>
</p><p>In the previous program, we have done the LED blinking experiment with one LED. Now, it’s time to up the stakes and do a bit more complicated experiment-traffic light. Actually, these two experiments are similar. While in this traffic light experiment, we use 3 LEDs with different color rather than one LED. <br>
</p><p><b>Hardware Required:</b><br>
1. Arduino board *1<br>
2. USB cable *1<br>
3. Red M5 LED*1 <br>
4. Yellow M5 LED*1<br>
5. Green M5 LED*1<br>
6. 220Ω resistor *3 <br>
7. Breadboard*1 <br>
8. Breadboard jumper wires* several<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6912.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6912.png" width="345" height="447"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6913.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6913.png" width="444" height="430"></a><br>
</p><p><b>Sample Code:</b><br>
Since it is a simulation of traffic light, the blinking time of each LED should be the same with those in traffic light system. In this program, we use Arduino delay () function to control delay time, which is much simpler than C language.
</p>
<pre>int redled =10; // initialize digital pin 8.
int yellowled =7; // initialize digital pin 7.
int greenled =4; // initialize digital pin 4.
void setup()
{
pinMode(redled, OUTPUT);// set the pin with red LED as “output”
pinMode(yellowled, OUTPUT); // set the pin with yellow LED as “output”
pinMode(greenled, OUTPUT); // set the pin with green LED as “output”
}
void loop()
{
digitalWrite(greenled, HIGH);//// turn on green LED
delay(5000);// wait 5 seconds

digitalWrite(greenled, LOW); // turn off green LED
for(int i=0;i&lt;3;i++)// blinks for 3 times
{
delay(500);// wait 0.5 second
digitalWrite(yellowled, HIGH);// turn on yellow LED
delay(500);// wait 0.5 second
digitalWrite(yellowled, LOW);// turn off yellow LED
} 
delay(500);// wait 0.5 second
digitalWrite(redled, HIGH);// turn on red LED
delay(5000);// wait 5 second
digitalWrite(redled, LOW);// turn off red LED
}</pre>
<p><b>Result:</b><br>
When the uploading process is completed, you can see traffic lights of your own design. <br>
Note: this circuit design is very similar with the one in LED chasing effect.<br>
The green light will be on for 5 seconds, and then off, followed by the yellow light blinking for 3 times, and then the red light is on for 5 seconds, repeatedly forming a cycle. <br>
Experiment is now completed. Thank you.
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_5:_LED_Chasing_Effect"><b>Project 5: LED Chasing Effect</b></span></h3>
<p><b>Introduction:</b>
</p><p>We often see billboards composed of colorful LEDs. They are constantly changing to form various effects. In this experiment, we compile a program to simulate chase effect.<br>
</p><p><b>Hardware Required:</b><br>
1. Led x6<br>
2. 220Ω resistor x6 <br>
3. Colorful breadboard wires<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6914.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6914.png" width="288" height="444"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6915.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6915.png" width="355" height="405"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>int BASE = 2&nbsp;;  // the I/O pin for the first LED
int NUM = 6;   // number of LEDs

void setup()
{
   for (int i = BASE; i &lt; BASE + NUM; i ++) 
   {
     pinMode(i, OUTPUT);   // set I/O pins as output
   }
}

void loop()
{
   for (int i = BASE; i &lt; BASE + NUM; i ++) 
   {
     digitalWrite(i, LOW);    // set I/O pins as “low”, turn off LEDs one by one.
     delay(200);        // delay
   }
   for (int i = BASE; i &lt; BASE + NUM; i ++) 
   {
     digitalWrite(i, HIGH);    // set I/O pins as “high”, turn on LEDs one by one
     delay(200);        // delay
   }  
}
</pre>
<p><b>Result:</b><br>
You can see the LEDs blink by sequence.
</p>
<h3><span class="mw-headline" id="Project_6:_Button-controlled_LED"><b>Project 6: Button-controlled LED</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Button_switch.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Button_switch.png" width="402" height="113"></a><br>
</p><p><b>Introduction:</b>
</p><p>I/O port means interface for INPUT and OUTPUT. Up until now, we have only used its OUTPUT function. In this experiment, we will try to use the input function, which is to read the output value of device connecting to it. We use 1 button and 1 LED using both input and output to give you a better understanding of the I/O function. Button switches, familiar to most of us, are a switch value (digital value) component. When it's pressed,the circuit is in closed (conducting) state.<br>
</p><p><b>Hardware Required:</b><br>
1. Button switch*1 <br>
2. Red M5 LED*1 <br>
3. 220Ω resistor*1<br>
4. 10KΩ resistor*1 <br>
5. Breadboard*1<br>
6. Breadboard jumper wires*several<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6916.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6916.png" width="357" height="455"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6917.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6917.png" width="456" height="440"></a><br>
</p><p><b>Sample Code:</b><br>
Now, let's begin the compiling. When the button is pressed, the LED will be on. Based on the previous study, the coding may be easy for you. In this program, we add a statement of judgment. Here, we use an if () statement.<br>
Arduino IDE is based on C language, so statements of C language such as while, switch etc. can certainly be used for Arduino program.<br>
When we press the button, pin 7 will output high level. We can program pin 11 to output high level and turn on the LED. When pin 7 outputs low level, pin 11 also outputs low level and the LED remains off.
</p>
<pre>int ledpin=11;// initialize pin 11
int inpin=7;// initialize pin 7
int val;// define val
void setup()
{
pinMode(ledpin,OUTPUT);// set LED pin as “output”
pinMode(inpin,INPUT);// set button pin as “input”

}
void loop()
{
val=digitalRead(inpin);// read the level value of pin 7 and assign if to val
if(val==LOW)// check if the button is pressed, if yes, turn on the LED
{ digitalWrite(ledpin,LOW);}
else
{ digitalWrite(ledpin,HIGH);}
}
</pre>
<p><b>Result:</b><br>
When the button is pressed, LED is on, otherwise, LED remains off. So the button controlled LED experiment is completed. The simple principle of this experiment is widely used in a variety of circuit and electric appliances. You can easily come across it in your everyday life. One typical example is when you press a certain key of your phone, the backlight will be on.
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_7:_Active_Buzzer"><b>Project 7: Active Buzzer</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Active_buzzer.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-Active_buzzer.png" width="300" height="243" srcset="/images/d/db/Active_buzzer.png 1.5x"></a><br>
</p><p><b>Introduction:</b>
</p><p>Active buzzer is widely used as a sound making element on computer, printer, alarm, electronic toy, telephone, timer, etc. It has an inner vibration source. Simply connect it with 5V power supply, it can buzz continuously. <br>
</p><p><b>Hardware Required:</b><br>
1. Buzzer*1<br>
2. Key *1 <br>
3. Breadboard*1 <br>
4. Breadboard jumper wires*several<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6918.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6918.png" width="334" height="470"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6919.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6919.png" width="390" height="392"></a><br>
When connecting the circuit, pay attention to the positive &amp; the negative poles of the buzzer. In the photo, you can see there are red and black lines. When the circuit is finished, you can begin the programming.
</p><p><b>Sample Code:</b><br>
Program is simple. You can control the buzzer by outputting high/low level.
</p>
<pre>int buzzer=8;// initialize digital IO pin that controls the buzzer
void setup() 
{ 
  pinMode(buzzer,OUTPUT);// set pin mode as “output”
} 
void loop() 
{
digitalWrite(buzzer, HIGH); // produce sound
}</pre>
<p><b>Result:</b><br>
After downloading the program, the buzzer experiment is completed. You can see the buzzer is ringing.
</p>
<h3><span class="mw-headline" id="Project_8:_Passive_Buzzer"><b>Project 8: Passive Buzzer</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Passive_buzzer.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Passive_buzzer.png" width="252" height="302"></a><br>
<b>Introduction:</b>
</p><p>You can use Arduino to make many interactive works.The most commonly used example is acoustic-optic display. All the previous experiment has something to do with LED. However, the circuit in this experiment can produce sound. Normally, the experiment is done with a buzzer or a speaker while buzzer is simpler and easier to use. The buzzer we introduced here is a passive buzzer. It cannot be actuated by itself, but by external pulse frequencies. Different frequencies produce different sounds. You can use Arduino to code the melody of a song, which is quite fun and simple. <br>
</p><p><b>Hardware Required:</b><br>
1.Passive buzzer*1<br>
2. Key *1 <br>
3. Breadboard*1 <br>
4. Breadboard jumper wires* several<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6920.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6920.png" width="328" height="463"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6921.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6921.png" width="413" height="417"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>int buzzer=8;// select digital IO pin for the buzzer
void setup() 
{ 
pinMode(buzzer,OUTPUT);// set digital IO pin pattern, OUTPUT to be output 
} 
void loop() 
{ unsigned char i,j;//define variable
while(1) 
{ for(i=0;i&lt;80;i++)// output a frequency sound
{ digitalWrite(buzzer,HIGH);// sound
delay(1);//delay1ms 
digitalWrite(buzzer,LOW);//not sound
delay(1);//ms delay 
} 
for(i=0;i&lt;100;i++)// output a frequency sound
{ digitalWrite(buzzer,HIGH);// sound
delay(2);//2ms delay 
digitalWrite(buzzer,LOW);//not sound
delay(2);//2ms delay 
}
} 
} 
</pre>
<p><b>Result:</b><br>
After downloading the program, the buzzer experiment is completed.
</p>
<h3><span class="mw-headline" id="Project_9:_RGB_LED"><b>Project 9: RGB LED</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:RGB_LED.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-RGB_LED.png" width="300" height="300" srcset="/images/thumb/9/94/RGB_LED.png/450px-RGB_LED.png 1.5x, /images/thumb/9/94/RGB_LED.png/600px-RGB_LED.png 2x"></a><br>
<b>Introduction:</b>
</p><p>Tricolor principle to display various colors;<br>
PWM controlling ports to display full color;<br>
Can be driven directly by Arduino PWM interfaces. <br>
</p><p><b>Hardware Required:</b><br>
</p>
<ul><li>Arduino controller × 1<br></li>
<li>USB cable × 1<br></li>
<li>Full-color LED module × 1<br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6922.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6922.png" width="334" height="508"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6923.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6923.png" width="407" height="450"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>int redpin = 11; //select the pin for the red LED
int bluepin =10; // select the pin for the blue LED
int greenpin =9;// select the pin for the green LED

int val;

void setup() {
  pinMode(redpin, OUTPUT);
  pinMode(bluepin, OUTPUT);
  pinMode(greenpin, OUTPUT);
  Serial.begin(9600);
}

void loop() 
{
for(val=255; val&gt;0; val--)
  {
   analogWrite(11, val);
   analogWrite(10, 255-val);
   analogWrite(9, 128-val);
   delay(1); 
  }
for(val=0; val&lt;255; val++)
  {
   analogWrite(11, val);
   analogWrite(10, 255-val);
   analogWrite(9, 128-val);
   delay(1); 
  }
 Serial.println(val, DEC);
}</pre>
<p><b>Result:</b><br>
Directly copy the above code into arduino IDE, and click upload <a href="https://wiki.keyestudio.com/File:690.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/690.png" width="35" height="34"></a>, wait for a few seconds, you can see a full-color LED.
</p>
<h3><span class="mw-headline" id="Project_10:_Photo_Resistor"><b>Project 10: Photo Resistor</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Photo_resistor.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Photo_resistor.png" width="318" height="215"></a><br>
</p><p><b>Introduction:</b>
</p><p>After completing all the previous experiments, you may acquire some basic understanding and knowledge about Arduino application. We have introduced digital input and output, analog input and PWM. Now, let's begin the learning of sensors applications.<br>
Photo resistor (Photovaristor) is a resistor whose resistance varies from the different incident light strength. It's made based on the photoelectric effect of semiconductor. If the incident light is intense, its resistance reduces; if the incident light is weak, the resistance increases. Photovaristor is commonly applied in the measurement of light, light control and photovoltaic conversion (convert the change of light into the change of electricity).<br>
Photo resistor is also widely applied to various light control circuit, such as light control and adjustment, optical switches, etc.We will start with a relatively simple experiment regarding to photovaristor application. Photovaristor is an element that will change its resistance as light strength changes. So need to read the analog values. You can refer to the PWM experiment, replacing the potentiometer with photovaristor. When there is change in light strength, it will cause corresponding change on the LED.
</p><p><b>Hardware Required:</b><br>
</p>
<ul><li>Photo resistor*1 <br></li>
<li>Red M5 LED*1 <br></li>
<li>10KΩresistor*1<br></li>
<li>220Ωresistor*1<br></li>
<li>Breadboard*1<br></li>
<li>Breadboard jumper wires*several<br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6924.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6924.png" width="336" height="418"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6925.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6925.png" width="423" height="395"></a><br>
</p><p><b>Sample Code:</b><br>
After the connection, let's begin the program compiling. The program is similar to the one of PWM. For change detail, please refer to the sample program below.
</p>
<pre>int potpin=0;// initialize analog pin 0, connected with photovaristor
int ledpin=11;// initialize digital pin 11, output regulating the brightness of LED
int val=0;// initialize variable va
void setup()
{
pinMode(ledpin,OUTPUT);// set digital pin 11 as “output”
Serial.begin(9600);// set baud rate at “9600”
}
void loop()
{
val=analogRead(potpin);// read the analog value of the sensor and assign it to val
Serial.println(val);// display the value of val
analogWrite(ledpin,val/4);// turn on the LED and set up brightness（maximum output value 255）
delay(10);// wait for 0.01
}</pre>
<p><b>Result:</b><br>
After downloading the program, you can change the light strength around the photovaristor and see corresponding brightness change of the LED. Photovaristors has various applications in our everyday life. You can make other interesting interactive projects based on this one.
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_11:_Flame_Sensor"><b>Project 11: Flame Sensor</b></span></h3>
<p><b>Introduction:</b>
</p><p>Flame sensor (Infrared receiving triode) is specially used on robots to find the fire source. This sensor is of high sensitivity to flame.
<br><a href="https://wiki.keyestudio.com/File:6926.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6926.png" width="275" height="124"></a><br>
</p><p><b>Working Principle:</b><br>
Flame sensor is based on the principle that infrared ray is highly sensitive to flame. It has an infrared receiving tube specially designed to detect fire, and then convert the flame brightness into fluctuating level signal. The signals are then input into the central processor and be dealt with accordingly.
</p><p><b>Sensor Connection:</b><br>
The shorter lead of the receiving triode is for negative, the other one for positive. Connect negative to 5V pin, positive to resistor; connect the other end of the resistor to GND, connect one end of a jumper wire to a clip which is electrically connected to sensor positive, the other end to analog pin. As shown below:
<br><a href="https://wiki.keyestudio.com/File:Flame_alarm.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Flame_alarm.png" width="442" height="488"></a><br>
</p><p><b>Hardware Required:</b><br>
1. Flame sensor*1 <br>
2. Buzzer*1<br>
3. 10K resistor*1 <br>
4. Breadboard jumper wires: several<br>
</p><p><b>Experiment Connection:</b><br>
1）Connecting buzzer:<br>
Connect the controller board, prototype board, breadboard and USB cable according to the Arduino tutorial. Connect the buzzer to digital pin 8.
</p><p>2）Connecting flame sensor:<br>
Connect the sensor to analog pin 0.
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6928.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6928.png" width="399" height="560"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6929.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6929.png" width="500" height="567" srcset="/images/9/9e/6929.png 1.5x"></a><br>
</p><p><b>Experiment Principle:</b><br>
When it's approaching a fire, the voltage value the analog port reads differs. If you use a multimeter, when there is no fire approaching, the voltage it reads is around 0.3V; when there is fire approaching, the voltage it reads is around 1.0V. The nearer the fire is, the higher the voltage is.
So in the beginning of the program, you can initialize voltage value i (no fire value); Then, continuously read the analog voltage value j and obtain difference value k=j-i; compare k with 0.6V (123 in binary) to determine whether there is a fire approaching or not; if yes, the buzzer will buzz.
</p><p><b>Sample Code:</b><br>
</p>
<pre>int flame=0;// select analog pin 0 for the sensor
 int Beep=9;// select digital pin 9 for the buzzer
 int val=0;// initialize variable
 void setup() 
{
  pinMode(Beep,OUTPUT);// set LED pin as “output”
 pinMode(flame,INPUT);// set buzzer pin as “input”
 Serial.begin(9600);// set baud rate at “9600”
 } 
void loop() 
{ 
  val=analogRead(flame);// read the analog value of the sensor 
  Serial.println(val);// output and display the analog value
  if(val&gt;=600)// when the analog value is larger than 600, the buzzer will buzz
  {  
   digitalWrite(Beep,HIGH); 
   }else 
   {  
     digitalWrite(Beep,LOW); 
    }
   delay(500); 
}</pre>
<p><b>Result:</b><br>
This program can simulate an alarm when there is a fire. Everything is normal when there is no fire; when there is fire, the alarm will be set off immediately.
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_12:_LM35_Temperature_Sensor"><b>Project 12: LM35 Temperature Sensor</b></span></h3>
<p><b>Introduction:</b>
</p><p>LM35 is a common and easy-to-use temperature sensor. It does not require other hardware. You just need an analog port to make it work. The difficulty lies in compiling the code to convert the analog value it reads to celsius temperature.
<br><a href="https://wiki.keyestudio.com/File:LM35.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/LM35.png" width="335" height="263"></a><br>
</p><p><b>Hardware Required:</b><br>
1. LM35*1 <br>
2. Breadboard*1<br>
3. Breadboard jumper wires*several<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6930.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6930.png" width="388" height="413"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6931.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6931.png" width="500" height="408" srcset="/images/6/67/6931.png 1.5x"></a><br>
</p><p><br>
<b>Sample Code:</b><br>
</p>
<pre>int potPin = 0; // initialize analog pin 0 for LM35 temperature sensor
void setup()
{
Serial.begin(9600);// set baud rate at”9600”
}
void loop()
{
int val;// define variable
int dat;// define variable
val=analogRead(0);// read the analog value of the sensor and assign it to val
dat=(125*val)&gt;&gt;8;// temperature calculation formula
Serial.print("Tep:");// output and display characters beginning with Tep
Serial.print(dat);// output and display value of dat
Serial.println("C");// display “C” characters
delay(500);// wait for 0.5 second
}
</pre>
<p><b>Result:</b><br>
After downloading the program, you can open the monitoring window to see the current temperature.
<br><a href="https://wiki.keyestudio.com/File:6932.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6932.png" width="327" height="371"></a><br>
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_13:_Tilt_Switch"><b>Project 13: Tilt Switch</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Tilt_switch.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-Tilt_switch.png" width="300" height="300" srcset="/images/thumb/4/4c/Tilt_switch.png/450px-Tilt_switch.png 1.5x, /images/4/4c/Tilt_switch.png 2x"></a><br>
<b>Introduction:</b>
</p><p>Tilt switch controlling the LED ON and OFF.
</p><p><b>Hardware Required:</b><br>
1. Ball switch*1<br>
2. Led *1 <br>
3. 220Ω resistor*1<br>
4. 10KΩ resistor*1<br>
5. Breadboard jumper wires:several<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6933.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6933.png" width="349" height="450"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6934.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6934.png" width="475" height="399"></a><br>
</p><p>Connect the controller board, shield, breadboard and USB cable according to Arduino tutorial. Connect the LED to digital pin 8, ball switch to analog pin 5.
</p><p><b>Experiment Principle:</b><br>
When one end of the switch is below horizontal position, the switch is on. The voltage of the analog port is about 5V (1023 in binary). The LED will be on. When the other end of the switch is below horizontal position, the switch is off. The voltage of the analog port is about 0V (0 in binary). The LED will be off. In the program, we determine whether the switch is on or off according to the voltage value of the analog port, whether it's above 2.5V (512 in binary) or not.
</p><p><b>Sample Code:</b><br>
</p>
<pre>void setup() 
{ 
  pinMode(8,OUTPUT);// set digital pin 8 as “output” 
} 
void loop() 
{ 
int i;// define variable i 
while(1) 
{ 
  i=analogRead(5);// read the voltage value of analog pin 5 
  if(i&gt;512)// if larger that 512（2.5V） 
  { 
    digitalWrite(8,LOW);// turn on LED 
  } 
  else// otherwise 
  { 
    digitalWrite(8,HIGH);// turn off LED 
  } 
 } 
}
</pre>
<p><b>Result:</b><br>
Hold the breadboard with your hand. Tilt it to a certain extent, the LED will be on. If there is no tilt, the LED will be off.<br>
The principle of this experiment can be applied to relay control. <br>
Experiment is completed.<br>
Thank you!
</p>
<h3><span class="mw-headline" id="Project_14:_IR_Remote_Control"><b>Project 14: IR Remote Control</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Ks0077_14-1.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-Ks0077_14-1.png" width="300" height="300" srcset="/images/thumb/9/99/Ks0077_14-1.png/450px-Ks0077_14-1.png 1.5x, /images/thumb/9/99/Ks0077_14-1.png/600px-Ks0077_14-1.png 2x"></a><br>
</p><p><b>Introduction:</b>
</p><p>What is an infrared receiver?<br>
The signal from the infrared remote controller is a series of binary pulse code. To avoid interference from other infrared signals during the wireless transmission, the signal is pre-modulate at a specific carrier frequency and then send out by an infrared emission diode. The infrared receiving device needs to filter out other wave and receive signal at that specific frequency and modulate it back to binary pulse code, known as demodulation.<br>
</p><p><b>Working Principle:</b><br>
The built-in receiver converts the light signal it received from the sender into feeble electrical signal. The signal will be amplified by the IC amplifier. After automatic gain control, band-pass filtering, demodulation, wave shaping, it returns to the original code. The code is then input to the code identification circuit by the receiver's signal output pin.<br>
The pin and the connection of the infrared receiving head.<br>
Pin and wiring of infrared receiver:<br>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_14-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Ks0077_14-2.png" width="460" height="470"></a><br>
<br><a href="https://wiki.keyestudio.com/File:6935.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6935.png" width="127" height="167"></a><br>
</p><p>Infrared receiver has 3 pins. <br>
When you use it, connect VOUT to analog pin, GND to GND, VCC to +5V.
</p><p><b>Hardware Required:</b><br>
</p>
<ul><li>Infrared remote controller x1<br></li>
<li>Infrared receiver x1 <br></li>
<li>LED x6<br></li>
<li>220Ω resistor x6 <br></li>
<li>Multi-color breadboard wires x several<br></li></ul>
<p><b>Connection Diagram:</b>
</p><p>First, connect the controller board; then connect the infrared receiver as the above mentioned, connect VOUT to digital pin 11, connect the LEDs with resistors and connect the resistors to pin2,3,4,5,6,7.
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6936.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6936.png" width="303" height="463"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6937.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6937.png" width="500" height="472" srcset="/images/8/87/6937.png 1.5x"></a><br>
</p><p><b>Experimental Principle:</b><br>
If you want to decode the code from a remote controller, you must first know how it's coded. The coding method we use here is NEC protocol. Below is a brief introduction.<br>
</p>
<ul><li>NEC protocol:<br></li></ul>
<p><b>Features：</b> <br>
(1) 8 bit address and 8 bit command length<br>
(2) address and command are transmitted twice for reliability<br>
(3) pulse distance modulation<br>
(4) carrier frequency of 38 KHZ <br>
(5) bit time of 1.125ms or 2.25ms<br>
Protocol is as below:<br>
</p>
<ul><li>Definition of logical 0 and 1 is as below</li></ul>
<p><br><a href="https://wiki.keyestudio.com/File:6938.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6938.png" width="427" height="124"></a><br>
</p>
<ul><li>Pulse transmitted when button is pressed and immediately released.</li></ul>
<p><br><a href="https://wiki.keyestudio.com/File:6939.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6939.png" width="500" height="99" srcset="/images/a/a6/6939.png 1.5x"></a><br>
</p><p>The picture above shows a typical pulse train of the NEC protocol. With this protocol the LSB is transmitted first. In this case Address $59 and Command $16 is transmitted. A message is started by a 9ms AGC burst, which was used to set the gain of the earlier IR receivers. This AGC burst is then followed by a 4.5ms space, which is then followed by the address and command. Address and Command are transmitted twice. The second time all bits are inverted and can be used for verification of the received message. The total transmission time is constant because every bit is repeated with its inverted length. If you are not interested in this reliability, you can ignore the inverted values, or you can expend the Address and Command to 16 bits each!
</p>
<ul><li>Pulse transmitted when button is pressed and released after a period of time</li></ul>
<p><br><a href="https://wiki.keyestudio.com/File:6940.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6940.png" width="500" height="105" srcset="/images/d/d8/6940.png 1.5x"></a><br>
</p><p>A command is transmitted only once, even when the key on the remote control remains pressed. Every 110ms a repeat code is transmitted for as long as the key remains down. This repeat code is simply a 9ms AGC pulse followed by a 2.25ms space and a 560µs burst.
</p>
<ul><li>Repeat pulse</li></ul>
<p><br><a href="https://wiki.keyestudio.com/File:6941.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6941.png" width="107" height="109"></a><br>
</p><p>Note: when the pulse enters the integrated receiver, there will be decoding, signal amplifying and wave shaping process. So you need to make sure the level of the output is just the opposite from that of the signal sending end. That is when there is no infrared signal, the output end is in high level; when there is infrared signal, the output end is in low level. You can see the pulse of the receiving end in the oscilloscope. Try to better understand the program base on what you see.
</p><p><b>Sample Code:</b><br>
</p>
<pre>#include &lt;IRremote.h&gt;
int RECV_PIN = 11;
int LED1 = 2;
int LED2 = 3;
int LED3 = 4;
int LED4 = 5;
int LED5 = 6;
int LED6 = 7;
long on1  = 0x00FF6897;
long off1 = 0x00FF9867;
long on2 = 0x00FFB04F;
long off2 = 0x00FF30CF;
long on3 = 0x00FF18E7;
long off3 = 0x00FF7A85;
long on4 = 0x00FF10EF;
long off4 = 0x00FF38C7;
long on5 = 0x00FF5AA5;
long off5 = 0x00FF42BD;
long on6 = 0x00FF4AB5;
long off6 = 0x00FF52AD;
IRrecv irrecv(RECV_PIN);
decode_results results;
// Dumps out the decode_results structure.
// Call this after IRrecv::decode()
// void * to work around compiler issue
//void dump(void *v) {
//  decode_results *results = (decode_results *)v
void dump(decode_results *results) {
  int count = results-&gt;rawlen;
  if (results-&gt;decode_type == UNKNOWN) 
    {
     Serial.println("Could not decode message");
    } 
  else 
   {
    if (results-&gt;decode_type == NEC) 
      {
       Serial.print("Decoded NEC: ");
      } 
    else if (results-&gt;decode_type == SONY) 
      {
       Serial.print("Decoded SONY: ");
      } 
    else if (results-&gt;decode_type == RC5) 
      {
       Serial.print("Decoded RC5: ");
      } 
    else if (results-&gt;decode_type == RC6) 
      {
       Serial.print("Decoded RC6: ");
      }
     Serial.print(results-&gt;value, HEX);
     Serial.print(" (");
     Serial.print(results-&gt;bits, DEC);
     Serial.println(" bits)");
   }
     Serial.print("Raw (");
     Serial.print(count, DEC);
     Serial.print("): ");
 for (int i = 0; i &lt; count; i++) 
     {
      if ((i&nbsp;% 2) == 1) {
      Serial.print(results-&gt;rawbuf[i]*USECPERTICK, DEC);
     } 
    else  
     {
      Serial.print(-(int)results-&gt;rawbuf[i]*USECPERTICK, DEC);
     }
    Serial.print(" ");
     }
      Serial.println("");
     }
void setup()
 {
  pinMode(RECV_PIN, INPUT);   
  pinMode(LED1, OUTPUT);
  pinMode(LED2, OUTPUT);
  pinMode(LED3, OUTPUT);
  pinMode(LED4, OUTPUT);
  pinMode(LED5, OUTPUT);
  pinMode(LED6, OUTPUT);  
  pinMode(13, OUTPUT);
  Serial.begin(9600);
   irrecv.enableIRIn(); // Start the receiver
 }
int on = 0;
unsigned long last = millis();

void loop() 
{
  if (irrecv.decode(&amp;results)) 
   {
    // If it's been at least 1/4 second since the last
    // IR received, toggle the relay
    if (millis() - last &gt; 250) 
      {
       on =&nbsp;!on;
//       digitalWrite(8, on&nbsp;? HIGH&nbsp;: LOW);
       digitalWrite(13, on&nbsp;? HIGH&nbsp;: LOW);
       dump(&amp;results);
      }
    if (results.value == on1 )
       digitalWrite(LED1, HIGH);
    if (results.value == off1 )
       digitalWrite(LED1, LOW); 
    if (results.value == on2 )
       digitalWrite(LED2, HIGH);
    if (results.value == off2 )
       digitalWrite(LED2, LOW); 
    if (results.value == on3 )
       digitalWrite(LED3, HIGH);
    if (results.value == off3 )
       digitalWrite(LED3, LOW);
    if (results.value == on4 )
       digitalWrite(LED4, HIGH);
    if (results.value == off4 )
       digitalWrite(LED4, LOW); 
    if (results.value == on5 )
       digitalWrite(LED5, HIGH);
    if (results.value == off5 )
       digitalWrite(LED5, LOW); 
    if (results.value == on6 )
       digitalWrite(LED6, HIGH);
    if (results.value == off6 )
       digitalWrite(LED6, LOW);        
    last = millis();      
irrecv.resume(); // Receive the next value
  }
}
</pre>
<p><b>Program Function</b><br>
Decode the coded pulse signal emitted by the remote controller, then execute corresponding action according to the results of the decoding. In this way, you are able to control your device with remote control.
</p><p><b>Result:</b><br>
<br><a href="https://wiki.keyestudio.com/File:6942.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6942.png" width="414" height="378"></a><br>
</p><p><b>Note：</b> add IRremote folder into installation directory \Arduino\compiler libraries, or it will fail to compile. <br>
For example：C:\Program Files\Arduino\libraries
</p>
<h3><span class="mw-headline" id="Project_15:_Analog_Value_Reading"><b>Project 15: Analog Value Reading</b></span></h3>
<p><b>Introduction:</b>
</p><p>In this experiment, we will begin the learning of analog I/O interfaces. On an Arduino, there are 6 analog interfaces numbered from 0 to 5. These 6 interfaces can also be used as digital ones numbered as 14-19. After a brief introduction, let's begin our project. Potentiometer used here is a typical output component of analog value that is familiar to us. <br>
</p><p><b>Hardware Required:</b><br>
1.Potentiometer *1 <br>
2.Breadboard*1<br>
3.Breadboard jumper wires * several<br>
</p><p><b>Connection:</b><br>
In this experiment, we will convert the resistance value of the potentiometer to analog ones and display it on the screen. This is an application you need to master well for our future experiments.<br>
Connection circuit as below:<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6943.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6943.png" width="317" height="444"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6944.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6944.png" width="380" height="378"></a><br>
</p><p>The analog interface we use here is interface A0.
</p><p><b>Sample Code:</b><br>
The program compiling is simple. An analogRead () Statement can read the value of the interface. The A/D acquisition of Arduino 328 is in 10 bits, so the value it reads is among 0 to 1023. One difficulty in this project is to display the value on the screen, which is actually easy to learn. First, we need to set the baud rate in voidsetup (). Displaying the value is a communication between Arduino and PC, so the baud rate of the Arduino should match the the one in the PC's software set up. Otherwise, the display will be messy codes or no display at all. In the lower right corner of the Arduino software monitor window, there is a button for baud rate set up. The set up here needs to match the one in the program. The statement in the program is Serial.begin(); enclosed is the baud rate value, followed by statement for displaying. You can either use Serial.print() or Serial.println() statement.
</p>
<pre>int potpin=0;// initialize analog pin 0
int ledpin=13;// initialize digital pin 13
int val=0;// define val, assign initial value 0
void setup()
{
pinMode(ledpin,OUTPUT);// set digital pin as “output”
Serial.begin(9600);// set baud rate at 9600

}
void loop()
{
digitalWrite(ledpin,HIGH);// turn on the LED on pin 13
delay(50);// wait for 0.05 second
digitalWrite(ledpin,LOW);// turn off the LED on pin 13
delay(50);// wait for 0.05 second
val=analogRead(potpin);// read the analog value of analog pin 0, and assign it to val 
Serial.println(val);// display val’s value
}
</pre>
<p><b>Result:</b><br>
The sample program uses the built-in LED connected to pin 13. Each time the device reads a value, the LED blinks.<br>
Below is the analog value it reads.<br>
<br><a href="https://wiki.keyestudio.com/File:6945.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6945.png" width="421" height="393"></a><br>
</p><p>When you rotate the potentiometer knob, you can see the displayed value change. The reading of analog value is a very common function for most sensors output analog value. After calculation, you can get the corresponding value you need.<br>
The experiment is now completed. Thank you.
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_16:_74HC595"><b>Project 16: 74HC595</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:74HC595.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-74HC595.png" width="300" height="317" srcset="/images/thumb/4/46/74HC595.png/450px-74HC595.png 1.5x, /images/thumb/4/46/74HC595.png/600px-74HC595.png 2x"></a><br>
</p><p><b>Introduction:</b><br>
To put it simply, 74HC595 is a combination of 8-digit shifting register, memorizer and equipped with tri-state output. Here, we use it to control 8 LEDs. You may wonder why use a 74HC595 to control LED? Well, think about how many I/O it takes for an Arduino to control 8 LEDs? Yes, 8. For an Arduino 168, it has only 20 I/O including analog ports. To save port resources, we use 74HC595 to reduce the number of ports it needs. Using 74HC595 enables us to use 3 digital I/O port to control 8 LEDs! <br>
</p><p><b>Hardware Required:</b><br>
1.74HC595 chip*1<br>
2.Red M5 LED*4 <br>
3.Green M5 LED*4<br>
4.220Ω resistor*8<br>
5.Breadboard*1 <br>
6.Breadboard jumper wires*several<br>
</p><p><b>Note:</b> for pin 13 OE port of 74HC595, it should be connected to GND<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6946.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6946.png" width="406" height="546"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6947.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6947.png" width="497" height="517"></a><br>
</p><p>The circuit may seem complicated, but soon you will find it easy!
</p><p><b>Sample Code:</b><br>
</p>
<pre>int data = 2;// set pin 14 of 74HC595as data input pin SI 
int clock = 5;// set pin 11 of 74hc595 as clock pin SCK
int latch = 4;// set pin 12 of 74hc595 as output latch RCK 
int ledState = 0;
const int ON = HIGH;
const int OFF = LOW;
void setup()
{
pinMode(data, OUTPUT);
pinMode(clock, OUTPUT);
pinMode(latch, OUTPUT);
}
void loop()
{
for(int i = 0; i &lt; 256; i++)
{
updateLEDs(i);
delay(500);
}
}
void updateLEDs(int value)
{
digitalWrite(latch, LOW);//
shiftOut(data, clock, MSBFIRST, ~value);// serial data “output”, high level first
digitalWrite(latch, HIGH);// latch
}
</pre>
<p><b>Result:</b><br>
After downloading the program, you can see 8 LEDs display 8-bit binary number.
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_17:_1-digit_LED_Segment_Display"><b>Project 17: 1-digit LED Segment Display</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:1-digit_LED.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-1-digit_LED.png" width="300" height="300" srcset="/images/thumb/8/85/1-digit_LED.png/450px-1-digit_LED.png 1.5x, /images/thumb/8/85/1-digit_LED.png/600px-1-digit_LED.png 2x"></a><br>
</p><p><b>Introduction:</b><br>
LED segment displays are common for displaying numerical information. It's widely applied on displays of electromagnetic oven, full automatic washing machine, water temperature display, electronic clock, etc. It is necessary for us to learn how it works.<br>
LED segment display is a semiconductor light-emitting device. Its basic unit is a light-emitting diode (LED). LED segment display can be divided into 7-segment display and 8-segment display according to the number of segments. 8-segment display has one more LED unit ( for decimal point display) than 7-segment one. In this experiment, we use a 8-segment display. According to the wiring method of LED units, LED segment displays can be divided into common anode display and common cathode display. Common anode display refers to the one that combine all the anodes of LED units into one common anode (COM).<br>
For the common anode display, connect the common anode (COM) to +5V. When the cathode level of a certain segment is low, the segment is on; when the cathode level of a certain segment is high, the segment is off. For the common cathode display, connect the common cathode (COM) to GND. When the anode level of a certain segment is high, the segment is on; when the anode level of a certain segment is low, the segment is off.<br>
<br><a href="https://wiki.keyestudio.com/File:1-digit_7-seg_%E8%8B%B1.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/1-digit_7-seg_英.png" width="331" height="272"></a><br>
</p><p><br>
Each segment of the display consists of an LED. So when you use it, you also need to use a current-limiting resistor. Otherwise, LED will be burnt out. In this experiment, we use a common cathode display. As we mentioned above, for common cathode display, connect the common cathode (COM) to GND. When the anode level of a certain segment is high, the segment is on; when the anode level of a certain segment is low, the segment is off.
</p><p><b>Hardware Required:</b><br>
1.1-digit LED display*1 <br>
2.220Ω resistor*8<br>
3.Breadboard*1 <br>
4.Breadboard jumper wires*several<br>
</p><p><b>Connection:</b><br>
Refer to following connection diagram
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6949.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6949.png" width="377" height="540"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6950.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6950.png" width="405" height="455"></a><br>
</p><p><b>Sample Code:</b><br>
</p><p>There are seven segments for numerical display, one for decimal point display. Corresponding segments will be turned on when displaying certain numbers. For example, when displaying number 1, b and c segments will be turned on. We compile a subprogram for each number, and compile the main program to display one number every 2 seconds, cycling display number 0 ~ 9. The displaying time for each number is subject to the delay time, the longer the delay time, the longer the displaying time.
</p>
<pre>// set the IO pin for each segment
int a=7;// set digital pin 7 for segment a
int b=6;// set digital pin 6 for segment b
int c=5;// set digital pin 5 for segment c
int d=10;// set digital pin 10 for segment d
int e=11;// set digital pin 11 for segment e
int f=8;// set digital pin 8 for segment f
int g=9;// set digital pin 9 for segment g
int dp=4;// set digital pin 4 for segment dp
void digital_0(void) // display number 5
{
unsigned char j;
digitalWrite(a,HIGH);
digitalWrite(b,HIGH);
digitalWrite(c,HIGH);
digitalWrite(d,HIGH);
digitalWrite(e,HIGH);
digitalWrite(f,HIGH);
digitalWrite(g,LOW);
digitalWrite(dp,LOW);
}
void digital_1(void) // display number 1
{
unsigned char j;
digitalWrite(c,HIGH);// set level as “high” for pin 5, turn on segment c
digitalWrite(b,HIGH);// turn on segment b
for(j=7;j&lt;=11;j++)// turn off other segments
digitalWrite(j,LOW);
digitalWrite(dp,LOW);// turn off segment dp
}
void digital_2(void) // display number 2
{
unsigned char j;
digitalWrite(b,HIGH);
digitalWrite(a,HIGH);
for(j=9;j&lt;=11;j++)
digitalWrite(j,HIGH);
digitalWrite(dp,LOW);
digitalWrite(c,LOW);
digitalWrite(f,LOW);
}
void digital_3(void) // display number 3
{digitalWrite(g,HIGH);
digitalWrite(a,HIGH);
digitalWrite(b,HIGH);
digitalWrite(c,HIGH);
digitalWrite(d,HIGH);
digitalWrite(dp,LOW);
digitalWrite(f,LOW);
digitalWrite(e,LOW);
}
void digital_4(void) // display number 4
{digitalWrite(c,HIGH);
digitalWrite(b,HIGH);
digitalWrite(f,HIGH);
digitalWrite(g,HIGH);
digitalWrite(dp,LOW);
digitalWrite(a,LOW);
digitalWrite(e,LOW);
digitalWrite(d,LOW);
}
void digital_5(void) // display number 5
{
unsigned char j;
digitalWrite(a,HIGH);
digitalWrite(b, LOW);
digitalWrite(c,HIGH);
digitalWrite(d,HIGH);
digitalWrite(e, LOW);
digitalWrite(f,HIGH);
digitalWrite(g,HIGH);
digitalWrite(dp,LOW);
}
void digital_6(void) // display number 6
{
unsigned char j;
for(j=7;j&lt;=11;j++)
digitalWrite(j,HIGH);
digitalWrite(c,HIGH);
digitalWrite(dp,LOW);
digitalWrite(b,LOW);
}
void digital_7(void) // display number 7
{
unsigned char j;
for(j=5;j&lt;=7;j++)
digitalWrite(j,HIGH);
digitalWrite(dp,LOW);
for(j=8;j&lt;=11;j++)
digitalWrite(j,LOW);
}
void digital_8(void) // display number 8
{
unsigned char j;
for(j=5;j&lt;=11;j++)
digitalWrite(j,HIGH);
digitalWrite(dp,LOW);
}
void digital_9(void) // display number 5
{
unsigned char j;
digitalWrite(a,HIGH);
digitalWrite(b,HIGH);
digitalWrite(c,HIGH);
digitalWrite(d,HIGH);
digitalWrite(e, LOW);
digitalWrite(f,HIGH);
digitalWrite(g,HIGH);
digitalWrite(dp,LOW);
}
void setup()
{
int i;// set variable
for(i=4;i&lt;=11;i++)
pinMode(i,OUTPUT);// set pin 4-11as “output”
}
void loop()
{
while(1)
{
digital_0();// display number 0
delay(1000);// wait for 1s
digital_1();// display number 1
delay(1000);// wait for 1s
digital_2();// display number 2
delay(1000); // wait for 1s
digital_3();// display number 3
delay(1000); // wait for 1s
digital_4();// display number 4
delay(1000); // wait for 1s
digital_5();// display number 5
delay(1000); // wait for 1s
digital_6();// display number 6
delay(1000); // wait for 1s
digital_7();// display number 7
delay(1000); // wait for 1s
digital_8();// display number 8
delay(1000); // wait for 1s
digital_9();// display number 9
delay(1000); // wait for 1s
}
}
</pre>
<p><b>Result:</b><br>
LED segment display will display the number from 0 to 9.
</p>
<h3><span class="mw-headline" id="Project_18:_4-digit_LED_Segment_Display"><b>Project 18: 4-digit LED Segment Display</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:4-LED_Display.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/4-LED_Display.png" width="314" height="258"></a><br>
</p><p><b>Introduction:</b><br>
In this experiment, we use an Arduino to drive a common anode, 4-digit, 7-segment LED display. For LED display, current-limiting resistors are indispensable. There are two wiring method for Current-limiting resistor. One is to connect one resistor for each anode, 4 in total for d1-d4 anode. An advantage for this method is that it requires fewer resistors, only 4. But it cannot maintain consistent brightness, 1 the brightest, 8, the least bright. Another method is to connect one resistor to each pin. It guarantees consistent brightness, but requires more resistors. In this experiment, we use 8 220Ω resistors (we use 220Ω resistors because no 100Ω resistor available. If you use 100Ω, the displaying is more brighter).
</p><p><b>Connection:</b><br>
For 4-digit displays, there are 12 pins in total. When you place the decimal point downward (see below photo position), the pin on the lower left part is refer to as 1, the upper left part 12.
</p><p><br><a href="https://wiki.keyestudio.com/File:17_(1).png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-17_(1).png" width="500" height="365" srcset="/images/thumb/d/d2/17_%281%29.png/750px-17_%281%29.png 1.5x, /images/d/d2/17_%281%29.png 2x"></a><br>
</p><p>Manual for LED segment display:
</p><p><br><a href="https://wiki.keyestudio.com/File:6953.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6953.png" width="432" height="489"></a><br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6954.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6954.png" width="500" height="293" srcset="/images/0/02/6954.png 1.5x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6955.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6955.png" width="500" height="235" srcset="/images/d/d2/6955.png 1.5x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>// display 1234 
	// select pin for cathode
	int a = 1;
	int b = 2;
	int c = 3;
	int d = 4;
	int e = 5;
	int f = 6;
	int g = 7;
	int dp = 8;
	// select pin for anode
	int d4 = 9;
	int d3 = 10;
	int d2 = 11;
	int d1 = 12;
	// set variable
	long n = 1230;
	int x = 100;
	int del = 55;  // fine adjustment for clock
	 
	void setup()
	{
	  pinMode(d1, OUTPUT);
	  pinMode(d2, OUTPUT);
	  pinMode(d3, OUTPUT);
	  pinMode(d4, OUTPUT);
	  pinMode(a, OUTPUT);
	  pinMode(b, OUTPUT);
	  pinMode(c, OUTPUT);
	  pinMode(d, OUTPUT);
	  pinMode(e, OUTPUT);
	  pinMode(f, OUTPUT);
	  pinMode(g, OUTPUT);
	  pinMode(dp, OUTPUT);
	}
/////////////////////////////////////////////////////////////
void loop()

{
 Display(1, 1);
 Display(2, 2);
 Display(3, 3);
 Display(4, 4);

}
///////////////////////////////////////////////////////////////
void WeiXuan(unsigned char n)//
{
    switch(n)
     {
	case 1: 
	  digitalWrite(d1,LOW);
 	  digitalWrite(d2, HIGH);
	  digitalWrite(d3, HIGH);
	  digitalWrite(d4, HIGH);   
	 break;
	 case 2: 
	  digitalWrite(d1, HIGH);
 	  digitalWrite(d2, LOW);
	  digitalWrite(d3, HIGH);
	  digitalWrite(d4, HIGH); 
	    break;
	  case 3: 
	    digitalWrite(d1,HIGH);
 	   digitalWrite(d2, HIGH);
	   digitalWrite(d3, LOW);
	   digitalWrite(d4, HIGH); 
	    break;
	  case 4: 
	   digitalWrite(d1, HIGH);
 	   digitalWrite(d2, HIGH);
	   digitalWrite(d3, HIGH);
	   digitalWrite(d4, LOW); 
	    break;
        default&nbsp;:
           digitalWrite(d1, HIGH);
	   digitalWrite(d2, HIGH);
	   digitalWrite(d3, HIGH);

	   digitalWrite(d4, HIGH);
        break;
	  }
}
void Num_0()
{
  digitalWrite(a, HIGH);
  digitalWrite(b, HIGH);
  digitalWrite(c, HIGH);
  digitalWrite(d, HIGH);
  digitalWrite(e, HIGH);
  digitalWrite(f, HIGH);
  digitalWrite(g, LOW);
  digitalWrite(dp,LOW);
}
void Num_1()
{
  digitalWrite(a, LOW);
  digitalWrite(b, HIGH);
  digitalWrite(c, HIGH);
  digitalWrite(d, LOW);
  digitalWrite(e, LOW);
  digitalWrite(f, LOW);
  digitalWrite(g, LOW);
  digitalWrite(dp,LOW);
}
void Num_2()
{
  digitalWrite(a, HIGH);
  digitalWrite(b, HIGH);
  digitalWrite(c, LOW);
  digitalWrite(d, HIGH);
  digitalWrite(e, HIGH);
  digitalWrite(f, LOW);
  digitalWrite(g, HIGH);
  digitalWrite(dp,LOW);
}
void Num_3()
{
  digitalWrite(a, HIGH);

  digitalWrite(b, HIGH);
  digitalWrite(c, HIGH);
  digitalWrite(d, HIGH);
  digitalWrite(e, LOW);
  digitalWrite(f, LOW);
  digitalWrite(g, HIGH);
  digitalWrite(dp,LOW);
}
void Num_4()
{
  digitalWrite(a, LOW);
  digitalWrite(b, HIGH);
  digitalWrite(c, HIGH);
  digitalWrite(d, LOW);
  digitalWrite(e, LOW);
  digitalWrite(f, HIGH);
  digitalWrite(g, HIGH);
  digitalWrite(dp,LOW);
}
void Num_5()
{
  digitalWrite(a, HIGH);
  digitalWrite(b, LOW);
  digitalWrite(c, HIGH);
  digitalWrite(d, HIGH);
  digitalWrite(e, LOW);
  digitalWrite(f, HIGH);
  digitalWrite(g, HIGH);
  digitalWrite(dp,LOW);
}
void Num_6()
{
  digitalWrite(a, HIGH);
  digitalWrite(b, LOW);
  digitalWrite(c, HIGH);
  digitalWrite(d, HIGH);
  digitalWrite(e, HIGH);
  digitalWrite(f, HIGH);
  digitalWrite(g, HIGH);
  digitalWrite(dp,LOW);

}
void Num_7()
{
  digitalWrite(a, HIGH);
  digitalWrite(b, HIGH);
  digitalWrite(c, HIGH);
  digitalWrite(d, LOW);
  digitalWrite(e, LOW);
  digitalWrite(f, LOW);
  digitalWrite(g, LOW);
  digitalWrite(dp,LOW);
}
void Num_8()
{
  digitalWrite(a, HIGH);
  digitalWrite(b, HIGH);
  digitalWrite(c, HIGH);
  digitalWrite(d, HIGH);
  digitalWrite(e, HIGH);
  digitalWrite(f, HIGH);
  digitalWrite(g, HIGH);
  digitalWrite(dp,LOW);
}
void Num_9()
{
  digitalWrite(a, HIGH);
  digitalWrite(b, HIGH);
  digitalWrite(c, HIGH);
  digitalWrite(d, HIGH);
  digitalWrite(e, LOW);
  digitalWrite(f, HIGH);
  digitalWrite(g, HIGH);
  digitalWrite(dp,LOW);
}
void Clear()  // clear the screen
{
  digitalWrite(a, LOW);
  digitalWrite(b, LOW);
  digitalWrite(c, LOW);
  digitalWrite(d, LOW);

  digitalWrite(e, LOW);
  digitalWrite(f, LOW);
  digitalWrite(g, LOW);
  digitalWrite(dp,LOW);
}
void pickNumber(unsigned char n)// select number
{
  switch(n)
  {
   case 0:Num_0();
   break;
   case 1:Num_1();
   break;
   case 2:Num_2();
   break;
   case 3:Num_3();
   break;
   case 4:Num_4();
   break;
   case 5:Num_5();
   break;
   case 6:Num_6();
   break;
   case 7:Num_7();
   break;
   case 8:Num_8();
   break;
   case 9:Num_9();
   break;
   default:Clear();
   break; 
  }
}
void Display(unsigned char x, unsigned char Number)//  take x as coordinate and display number
{
  WeiXuan(x);
  pickNumber(Number);
 delay(1);
 Clear()&nbsp;; // clear the screen
}</pre>
<p><b>Result:</b><br>
Download the above code to the controller board and see the result. <br>
It will display the number 1234.<br>
Note: if it’s not displaying correctly, check the wiring.<br>
Thank you.
</p><p><br>
</p>
<h3><span id="Project_19:_8*8_LED_Matrix"></span><span class="mw-headline" id="Project_19:_8.2A8_LED_Matrix"><b>Project 19: 8*8 LED Matrix</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:6956.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6956.png" width="372" height="372"></a><br>
</p><p><b>Introduction:</b><br>
With low-voltage scanning, LED dot-matrix display have some advantages such as power saving, long service life, low cost, high brightness, wide angle of view, long visual range, waterproof, and numerous specifications. LED dot-matrix display can meet the needs of different applications, thus have a broad development prospect. This time, we will conduct an LED dot-matrix experiment to experience its charm firsthand.
</p><p><b>Hardware Required:</b><br>
</p>
<ul><li>1 * Uno board</li>
<li>1 * 8*8 dot-matrix</li>
<li>8 * Resistor (220Ω)</li>
<li>1 * Breadboard</li>
<li>1 * USB cable</li>
<li>Jumper wires</li></ul>
<p><b>Connection:</b><br>
The external view of a dot-matrix is shown as follows:
<br><a href="https://wiki.keyestudio.com/File:6957.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6957.png" width="286" height="273"></a><br>
</p><p>The display principle of the 8*8 dot-matrix:<br>
</p><p>The 8*8 dot-matrix is made up of sixty-four LEDs, and each LED is placed at the cross point of a row and a column. When the electrical level of a certain row is 1 and the electrical level of a certain column is 0, the corresponding LED will be on. If you want to light the LED on the first dot, you should set pin 9 to high level and pin 13 to low level. If you want to light LEDs on the first row, you should set pin 9 to high level and pins 13, 3, 4, 10, 6, 11, 15 and 16 to low level. If you want to light the LEDs on the first column, set pin 13 to low level and pins 9, 14, 8, 12, 1, 7, 2 and 5 to high level.<br>
The internal view of a dot-matrix is shown as follows:<br>
<br><a href="https://wiki.keyestudio.com/File:6958.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6958.png" width="431" height="213"></a><br>
</p><p>The principle of 74HC595 has been previously illustrated. One chip is used to control the rows of the dot-matrix while the other chip is used to control the columns.
</p><p>Connect circuit as shown in the following diagram:<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks078-%E5%9B%BE%E7%89%87uno.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Ks078-图片uno.png" width="554" height="269"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks078-%E5%9B%BE%E7%89%871.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Ks078-图片1.png" width="554" height="251"></a><br>
</p><p><b>Sample Code for Displaying “0”:</b><br>
</p>
<pre>// set an array to store character of “0”
unsigned char Text[]={0x00,0x1c,0x22,0x22,0x22,0x22,0x22,0x1c};
void Draw_point(unsigned char x,unsigned char y)// point drawing function
{ clear_();
   digitalWrite(x+2, HIGH);
   digitalWrite(y+10, LOW);
   delay(1);
}
void show_num(void)// display function, call point drawing function
{
  unsigned char i,j,data;
  for(i=0;i&lt;8;i++)
  {
    data=Text[i];
    for(j=0;j&lt;8;j++)
    {
      if(data &amp; 0x01)Draw_point(j,i);
      data&gt;&gt;=1;

    }  
  }
}
void setup(){ 
int i = 0&nbsp;; 
for(i=2;i&lt;18;i++) 
 { 
   pinMode(i, OUTPUT); 
  }  
  clear_(); 
}
void loop()
{ show_num();    
} 
void clear_(void)// clear screen
{for(int i=2;i&lt;10;i++)
  digitalWrite(i, LOW);
  for(int i=0;i&lt;8;i++)
  digitalWrite(i+10, HIGH);
}
</pre>
<p><b>Result:</b><br>
Burn the program into Uno board, the dot-matrix will display 0.
</p>
<h3><span class="mw-headline" id="Project_20:_1602_LCD"><b>Project 20: 1602 LCD</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:1602LCD.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/1602LCD.png" width="475" height="206"></a><br>
</p><p><b>Introduction:</b><br>
In this experiment, we use an Arduino to drive the 1602 LCD.<br>
1602 LCD has wide applications. In the beginning,1602 LCD uses a HD44780 controller. Now, almost all 1602 LCD module uses a compatible IC, but their features are basically the same.
</p><p><b>1602LCD Parameters:</b>
</p>
<ul><li>Display Capacity: 16 × 2 characters.</li>
<li>Chip Operating Voltage: 4.5 ~ 5.5V.</li>
<li>Working Current: 2.0mA (5.0V).</li>
<li>Optimum working voltage of the module is 5.0V.</li>
<li>Character Size: 2.95 * 4.35 (W * H) mm.</li></ul>
<p><b>Pin Description of 1602 LCD：</b><br>
</p>
<table width="80%" cellspacing="0" border="1">
<tbody><tr>
<th align="center" scope="col">No.
</th>
<th align="center" scope="col">Mark
</th>
<th align="center" scope="col">Pin Description
</th>
<th align="center" scope="col">No.
</th>
<th align="center" scope="col">Mark
</th>
<th align="center" scope="col">Pin Description
</th></tr>
<tr>
<td align="center">1
</td>
<td align="center">VSS
</td>
<td align="center">Power GND
</td>
<td align="center">9
</td>
<td align="center">D2
</td>
<td align="center">Date I/O
</td></tr>
<tr>
<td align="center">2
</td>
<td align="center">VDD
</td>
<td align="center">Power Positive
</td>
<td align="center">10
</td>
<td align="center">D3
</td>
<td align="center">Date I/O
</td></tr>
<tr>
<td align="center">3
</td>
<td align="center">VL
</td>
<td align="center">LCD Voltage Bias Signal
</td>
<td align="center">11
</td>
<td align="center">D4
</td>
<td align="center">Date I/O
</td></tr>
<tr>
<td align="center">4
</td>
<td align="center">RS
</td>
<td align="center">Select data/command(V/L)
</td>
<td align="center">12
</td>
<td align="center">D5
</td>
<td align="center">Date I/O
</td></tr>
<tr>
<td align="center">5
</td>
<td align="center">R/W
</td>
<td align="center">Select read/write(H/L)
</td>
<td align="center">13
</td>
<td align="center">D6
</td>
<td align="center">Date I/O
</td></tr>
<tr>
<td align="center">6
</td>
<td align="center">E
</td>
<td align="center">Enable Signal
</td>
<td align="center">14
</td>
<td align="center">D7
</td>
<td align="center">Date I/O
</td></tr>
<tr>
<td align="center">7
</td>
<td align="center">D0
</td>
<td align="center">Date I/O
</td>
<td align="center">15
</td>
<td align="center">BLA
</td>
<td align="center">Back Light Power Positive
</td></tr>
<tr>
<td align="center">8
</td>
<td align="center">D1
</td>
<td align="center">Date I/O
</td>
<td align="center">16
</td>
<td align="center">BLK
</td>
<td align="center">Back Light Power Negative
</td></tr>
</tbody></table>
<p><b>Interface Description:</b><br>
1. two power sources, one for module power, another one for backlight, generally use 5V. In this project, we use 3.3V for backlight.<br>
2. VL is the pin for adjusting contrast ratio; it usually connects a potentiometer(no more than 5KΩ) in series for its adjustment. In this experiment, we use a 1KΩ resistor. For the connection, it has 2 methods, namely high potential and low potential. Here, we use low potential method; connect the resistor and then the GND.<br>
3. RS is a very common pin in LCD. It's a selecting pin for command/data. When the pin is in high level, it's in data mode; when it's in low level, it's in command mode.<br>
4. RW pin is also very common in LCD. It's a selecting pin for read/write. When the pin is in high level, it's in read operation; when it's in low level, it's in write operation.<br>
5. E pin is also very common in LCD. Usually, when the signal in the bus is stabilized, it sends out a positive pulse requiring read operation. When this pin is in high level, the bus is not allowed to have any change.<br>
6. D0-D7 is 8-bit bidirectional parallel bus, used for command and data transmission.<br>
7. BLA is anode for back light; BLK, cathode for back light.<br>
</p><p><b>4 Basic Operations of 1602LCD:</b><br>
</p>
<table width="80%" cellspacing="0" border="1">
<tbody><tr>
<td align="center">Read status
</td>
<td align="center">input
</td>
<td align="center">RS=L, R/W=H, E=H
</td>
<td align="center">output
</td>
<td align="center">D0-D7=status word
</td></tr>
<tr>
<td align="center">Write command
</td>
<td align="center">input
</td>
<td align="center">RS=L, R/W=H, D0-D7=command code, E=high pulse
</td>
<td align="center">output
</td>
<td align="center">none
</td></tr>
<tr>
<td align="center">Read data
</td>
<td align="center">input
</td>
<td align="center">RS=H, R/W=H, E=H
</td>
<td align="center">output
</td>
<td align="center">D0-D7=data
</td></tr>
<tr>
<td align="center">Write data
</td>
<td align="center">input
</td>
<td align="center">RS=H, R/W=L, D0-D7=data, E=high pulse
</td>
<td align="center">output
</td>
<td align="center">none
</td></tr>
</tbody></table>
<p><b>Hardware Required:</b><br>
</p>
<ul><li>1 * Controller Board</li>
<li>1 * 1602 LCD</li>
<li>1 * Potentiometer</li>
<li>1 * Breadboard</li>
<li>1 * USB Cable</li>
<li>Jumper Wires</li></ul>
<p><b>Connection &amp; Sample Program:</b><br>
1602 can directly communicate with Arduino. According to the product manual, it has two connection methods, namely 8-bit connection and 4-bit connection.
</p><p><b>8-bit connection method:</b>
<br><a href="https://wiki.keyestudio.com/File:6961.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6961.png" width="305" height="369"></a><br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_20-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_20-3.png" width="500" height="223" srcset="/images/thumb/f/f1/Ks0077_20-3.png/750px-Ks0077_20-3.png 1.5x, /images/thumb/f/f1/Ks0077_20-3.png/1000px-Ks0077_20-3.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6963.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6963.png" width="500" height="286" srcset="/images/f/f4/6963.png 1.5x"></a><br>
</p><p><b>Sample Code A:</b><br>
</p>
<pre>int DI = 12;
int RW = 11;
int DB[] = {3, 4, 5, 6, 7, 8, 9, 10};// use array to select pin for bus
int Enable = 2;

void LcdCommandWrite(int value) {
// define all pins
int i = 0;
for (i=DB[0]; i &lt;= DI; i++) // assign value for bus
{
   digitalWrite(i,value &amp; 01);// for 1602 LCD, it uses D7-D0( not D0-D7) for signal identification; here, it’s used for signal inversion. 
   value &gt;&gt;= 1;
}
digitalWrite(Enable,LOW);
delayMicroseconds(1);
digitalWrite(Enable,HIGH);
delayMicroseconds(1);  // wait for 1ms
digitalWrite(Enable,LOW);
delayMicroseconds(1);  // wait for 1ms
}

void LcdDataWrite(int value) {
// initialize all pins
int i = 0;
digitalWrite(DI, HIGH);
digitalWrite(RW, LOW);
for (i=DB[0]; i &lt;= DB[7]; i++) {
   digitalWrite(i,value &amp; 01);
   value &gt;&gt;= 1;
}
digitalWrite(Enable,LOW);
delayMicroseconds(1);
digitalWrite(Enable,HIGH);
delayMicroseconds(1);
digitalWrite(Enable,LOW);
delayMicroseconds(1);  // wait for 1ms
}

void setup (void) {
int i = 0;
for (i=Enable; i &lt;= DI; i++) {
   pinMode(i,OUTPUT);
}
delay(100);
// initialize LCD after a brief pause
// for LCD control
LcdCommandWrite(0x38);  // select as 8-bit interface, 2-line display, 5x7 character size 
delay(64);                      
LcdCommandWrite(0x38);  // select as 8-bit interface, 2-line display, 5x7 character size 
delay(50);                      
LcdCommandWrite(0x38);  // select as 8-bit interface, 2-line display, 5x7 character size             
delay(20);                      
LcdCommandWrite(0x06);  // set input mode
                         // auto-increment, no display of shifting
delay(20);                      
LcdCommandWrite(0x0E);  // display setup
                         // turn on the monitor, cursor on, no flickering
delay(20);                      
LcdCommandWrite(0x01);  // clear the scree, cursor position returns to 0
delay(100);                      
LcdCommandWrite(0x80);  //  display setup
                         //  turn on the monitor, cursor on, no flickering

delay(20);                      
}

void loop (void) {
  LcdCommandWrite(0x01);  // clear the scree, cursor position returns to 0  
  delay(10); 
  LcdCommandWrite(0x80+3); 
  delay(10);                     
  // write in welcome message 
  LcdDataWrite('W');
  LcdDataWrite('e');
  LcdDataWrite('l');
  LcdDataWrite('c');
  LcdDataWrite('o');
  LcdDataWrite('m');

  LcdDataWrite('e');
  LcdDataWrite(' ');
  LcdDataWrite('t');
  LcdDataWrite('o');
  delay(10);
  LcdCommandWrite(0xc0+1);  // set cursor position at second line, second position
  delay(10); 
  LcdDataWrite('g');
  LcdDataWrite('e');
  LcdDataWrite('e');
  LcdDataWrite('k');
  LcdDataWrite('-');
  LcdDataWrite('w');
  LcdDataWrite('o');
  LcdDataWrite('r');
  LcdDataWrite('k');
  LcdDataWrite('s');
  LcdDataWrite('h');
  LcdDataWrite('o');
  LcdDataWrite('p');
  delay(5000);
  LcdCommandWrite(0x01);  // clear the screen, cursor returns to 0  
  delay(10);
  LcdDataWrite('I');
  LcdDataWrite(' ');
  LcdDataWrite('a');
  LcdDataWrite('m');
  LcdDataWrite(' ');
  LcdDataWrite('h');
  LcdDataWrite('o');
  LcdDataWrite('n');
  LcdDataWrite('g');
  LcdDataWrite('y');
  LcdDataWrite('i');
  delay(3000);
  LcdCommandWrite(0x02); // set mode as new characters replay old ones, where there is no new ones remain the same
  delay(10);
  LcdCommandWrite(0x80+5); // set cursor position at first line, sixth position
  delay(10);  

  LcdDataWrite('t');
  LcdDataWrite('h');
  LcdDataWrite('e');
  LcdDataWrite(' ');
  LcdDataWrite('a');
  LcdDataWrite('d');
  LcdDataWrite('m');
  LcdDataWrite('i');
  LcdDataWrite('n');
  delay(5000);
}
</pre>
<p><b>4-bit connection method:</b><br>
When using this module, 8-bit connection uses all the digital pins of the Arduino, leaving no pin for sensors. What then? you can use 4-bit connection.
</p><p><b>Connection Circuit:</b><br>
<b>Connection for UNO R3:</b><br>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_20-1.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_20-1.png" width="500" height="302" srcset="/images/thumb/f/fd/Ks0077_20-1.png/750px-Ks0077_20-1.png 1.5x, /images/thumb/f/fd/Ks0077_20-1.png/1000px-Ks0077_20-1.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_20-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_20-2.png" width="500" height="282" srcset="/images/thumb/f/f6/Ks0077_20-2.png/750px-Ks0077_20-2.png 1.5x, /images/thumb/f/f6/Ks0077_20-2.png/1000px-Ks0077_20-2.png 2x"></a><br>
After the connection, upload below code to the controller board and see how it goes.
</p><p><b>Sample Code B:</b><br>
</p>
<pre>/*
  LiquidCrystal Library - Hello World

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch prints "Hello World!" to the LCD
 and shows the time.

  The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 9
 * LCD D5 pin to digital pin 8
 * LCD D6 pin to digital pin 7
 * LCD D7 pin to digital pin 6
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystal
 */

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(12, 11, 9, 8, 7, 6);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  lcd.print("hello, world!");
}

void loop() {
  // set the cursor to column 0, line 1
  // (note: line 1 is the second row, since counting begins with 0):
  lcd.setCursor(0, 1);
  // print the number of seconds since reset:
  lcd.print(millis() / 1000);
}
</pre>
<h3><span class="mw-headline" id="Project_21:_9g_Servo_Control"><b>Project 21: 9g Servo Control</b></span></h3>
<p><b>Introduction:</b> <br>
</p><p>Servomotor is a position control rotary actuator. It mainly consists of housing, circuit board, core-less motor, gear and position sensor. The receiver or MCU outputs a signal to the servomotor. The motor has a built-in reference circuit that gives out reference signal, cycle of 20ms and width of 1.5ms. The motor compares the acquired DC bias voltage to the voltage of the potentiometer and outputs a voltage difference. The IC on the circuit board will decide the rotate direction accordingly and drive the core-less motor. The gear then pass the force to the shaft. The sensor will determine whether it has reached the commanded position according to the feedback signal. Servomotors are used in control systems that require to have and maintain different angles. When the motor speed is definite, the gear will cause the potentiometer to rotate. When the voltage difference reduces to zero, the motor stops. Normally, the rotation angle range is among 0-180 degrees.
</p><p><br><a href="https://wiki.keyestudio.com/File:Servo.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Servo.png" width="152" height="112"></a><br>
</p><p>Servomotor comes with many specifications. But all of them have three connection wires, distinguished by brown, red, orange(different brand may have different colors. Brown one is for GND, red one for power positive, orange one for signal line.
</p><p><br><a href="https://wiki.keyestudio.com/File:6967.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6967.png" width="500" height="163" srcset="/images/f/fb/6967.png 1.5x"></a><br>
</p><p>The rotate angle of the servo motor is controlled by regulating the duty cycle of the PWM(Pulse-Width Modulation) signal. The standard cycle of the PWM signal is 20ms（50Hz）. Theoretically, the width is distributed between 1ms-2ms, but in fact, it's between 0.5ms-2.5ms. The width corresponds the rotate angle from 0° to 180°. But note that for different brand motor, the same signal may have different rotating angles.
</p><p><br><a href="https://wiki.keyestudio.com/File:6968.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6968.png" width="500" height="196" srcset="/images/9/94/6968.png 1.5x"></a><br>
</p><p>With some basic knowledge, let's learn how to control a servomotor. In this experiment, you only need a servomotor and several jumper wires.
</p><p><b>Hardware Required:</b><br>
</p>
<ul><li>RB—412 servomotor*1</li>
<li>Breadboard jumper wire*several</li></ul>
<p><b>Connection &amp; Sample Program:</b>
</p><p>There are two ways to control a servomotor with Arduino. One is to use a common digital port of Arduino to produce square wave with different duty cycle to simulate PWM signal, and then use that signal to control the positioning of the motor. Another way is to directly use the Servo function of the Arduino to control the motor. In this way, the program will be more easier but it can only control two-contact motor for the servo function, only digital pin 9 and 10 is available. The Arduino
drive capacity is limited. So if you need to control more than one motor, you will need external power.
</p><p><b>Method 1:</b><br>
<b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6969.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/6969.png" width="388" height="496"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:6970.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-6970.png" width="500" height="454" srcset="/images/e/e2/6970.png 1.5x"></a><br>
</p><p>Connect the motor to digital pin 9.
Compile a program to control the motor to rotate in the commanded angle, and display the angle on the screen.
</p><p><b>Sample Code A:</b><br>
</p>
<pre>int servopin=9;// select digital pin 9 for servomotor signal line
int myangle;// initialize angle variable
int pulsewidth;// initialize width variable
int val;
void servopulse(int servopin,int myangle)// define a servo pulse function
{
pulsewidth=(myangle*11)+500;// convert angle to 500-2480 pulse width
digitalWrite(servopin,HIGH);// set the level of servo pin as “high”
delayMicroseconds(pulsewidth);// delay microsecond of pulse width
digitalWrite(servopin,LOW);// set the level of servo pin as “low”
delay(20-pulsewidth/1000);
}

void setup()
{
pinMode(servopin,OUTPUT);// set servo pin as “output”
Serial.begin(9600);// connect to serial port, set baud rate at “9600”
Serial.println("servo=o_seral_simple ready" )&nbsp;;
}
void loop()// convert number 0 to 9 to corresponding 0-180 degree angle, LED blinks corresponding number of time
{
val=Serial.read();// read serial port value
if(val&gt;='0'&amp;&amp;val&lt;='9')
{
val=val-'0';// convert characteristic quantity to numerical variable
val=val*(180/9);// convert number to angle
Serial.print("moving servo to ");
Serial.print(val,DEC);
Serial.println();
for(int i=0;i&lt;=50;i++) // giving the servo time to rotate to commanded position
{
servopulse(servopin,val);// use the pulse function
}
}
}
</pre>
<p><br>
<b>Method 2:</b>
</p><p>Let's first take a look at the Arduino built-in servo function and some common statements.<br>
1. attach（interface）——select pin for servo, can only use pin 9 or 10.<br>
2. write（angle）——used to control the rotate angle of the servo, can set the angle among 0 degree to 180 degree.<br>
3. read（）——used to read the angle of the servo, consider it a function to read the value in the write() function.<br>
4. attached（）——determine whether the parameter of the servo is sent to the servo pin.<br>
5. detach（）—— disconnect the servo and the pin, and the pin(digital pin 9 or 10) can be used for PWM port. <br>
Note: the written form of the above statements are " servo variable name. specific statement ()", e.g. myservo. Attach (9).<br>
Still, connect the servo to pin 9.
</p><p><b>Sample Code B:</b><br>
</p>
<pre>#include &lt;Servo.h&gt;
/* define a header file. Special attention here, you can call the servo function directly from Arduino's software menu  bar Sketch&gt;Importlibrary&gt;Servo, or input 
#include &lt;Servo.h&gt;. Make sure there is a space between #include and  &lt;Servo.h&gt;. Otherwise, it will cause compile error.*/
Servo myservo;// define servo variable name
void setup()
{
myservo.attach(9);// select servo pin(9 or 10)
}
void loop()
{
myservo.write(90);// set rotate angle of the motor
}
</pre>
<p>Above are the two methods to control the servo. You can choose either one according to your liking or actual need.
</p>
<h3><span class="mw-headline" id="Project_22:_5V_Stepper_Motor"><b>Project 22: 5V Stepper Motor</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Pro22-stepper.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Pro22-stepper.png" width="500" height="296" srcset="/images/thumb/e/e4/Pro22-stepper.png/750px-Pro22-stepper.png 1.5x, /images/e/e4/Pro22-stepper.png 2x"></a><br>
</p><p><b>Introduction:</b><br>
A stepper motor is an electromechanical device which converts electrical pulses into discrete mechanical movements. The shaft or spindle of a stepper motor rotates in discrete step increments when electrical command pulses are applied to it in the proper sequence. The motors rotation has several direct relationships to these applied input pulses. The sequence of the applied pulses is directly related to the direction of motor shafts rotation. The speed of the motor shafts rotation is directly related to the frequency of the input pulses and the length of rotation is directly related to the number of input pulses applied.One of the most significant advantages of a stepper motor is its ability to be accurately controlled in an open loop system. Open loop control means no feedback information about position is needed. This type of control eliminates the need for expensive sensing and feedback devices such as optical encoders. Your position is known simply by keeping track of the input step pulses.<br>
</p><p><b>Features:</b><br>
</p>
<ul><li>The rotation angle of the motor is proportional to the input pulse.<br></li>
<li>The motor has full torque at standstill(if the windings are energized)<br></li>
<li>Precise positioning and repeatability of movement since good stepper motors have an accuracy of – 5% of a step and this error is non cumulative from one step to the next.<br></li>
<li>Excellent response to starting/stopping/reversing.<br></li>
<li>Very reliable since there are no contact brushes in the motor. Therefore the life of the motor is simply dependant on the life of the bearing.<br></li>
<li>The motors response to digital input pulses provides open-loop control, making the motor simpler and less costly to control.<br></li>
<li>It is possible to achieve very low speed synchronous rotation with a load that is directly coupled to the shaft.<br></li>
<li>A wide range of rotational speeds can be realized as the speed is proportional to the frequency of the input pulses.<br></li></ul>
<p><b>Parameters of Stepper Motor 28BYJ-48:<br></b>
</p>
<ul><li>Model: 28BYJ-48<br></li>
<li>Rated voltage: 5VDC<br></li>
<li>Number of Phase: 4<br></li>
<li>Speed Variation Ratio: 1/64<br></li>
<li>Stride Angle: 5.625° /64<br></li>
<li>Frequency: 100Hz<br></li>
<li>DC resistance: 50Ω±7%(25℃)<br></li>
<li>Idle In-traction Frequency: &gt; 600Hz<br></li>
<li>Idle Out-traction Frequency: &gt; 1000Hz<br></li>
<li>In-traction Torque &gt;34.3mN.m(120Hz)<br></li>
<li>Self-positioning Torque &gt;34.3mN.m<br></li>
<li>Friction torque: 600-1200 gf.cm<br></li>
<li>Pull in torque: 300 gf.cm<br></li>
<li>Insulated resistance &gt;10MΩ(500V)<br></li>
<li>Insulated electricity power: 600VAC/1mA/1s<br></li>
<li>Insulation grade: A<br></li>
<li>Rise in Temperature &lt;40K(120Hz)<br></li>
<li>Noise &lt;35dB(120Hz,No load,10cm)<br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Pro22-wiring1.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Pro22-wiring1.png" width="500" height="251" srcset="/images/thumb/c/c1/Pro22-wiring1.png/750px-Pro22-wiring1.png 1.5x, /images/thumb/c/c1/Pro22-wiring1.png/1000px-Pro22-wiring1.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Pro22-wiring2.jpg" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Pro22-wiring2.jpg" width="500" height="198" srcset="/images/thumb/9/99/Pro22-wiring2.jpg/750px-Pro22-wiring2.jpg 1.5x, /images/thumb/9/99/Pro22-wiring2.jpg/1000px-Pro22-wiring2.jpg 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>#include &lt;Stepper.h&gt;   
#define STEPS 100  
Stepper stepper(STEPS, 8, 9, 10, 11);  
int previous = 0;  
void setup()
{
  stepper.setSpeed(90);
 }   
 void loop()
 {    
   int val = analogRead(0);      
   stepper.step(val - previous);     
   previous = val;
 }
</pre>
<h3><span class="mw-headline" id="Project_23:_PIR_Motion_Sensor"><b>Project 23: PIR Motion Sensor</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:PIR_motion.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/PIR_motion.png" width="322" height="247"></a><br>
</p><p><b>Introduction:</b><br>
Pyroelectric infrared motion sensor can detect infrared signals from a moving person or moving animal, and output switching signals. It can be applied to a variety of occasions to detect the movement of human body. Conventional pyroelectric infrared sensors require body pyroelectric infrared detector, professional chip, complex peripheral circuit, so its size is much more bigger, with complex circuit and lower reliability. <br>
Now we launch this new pyroelectric infrared motion sensor,which is specially designed for Arduino. It uses an integrated digital body pyroelectric infrared sensor, and has smaller size, higher reliability, lower power consumption and simpler peripheral circuit.<br>
</p><p><b>Specification:</b><br>
</p>
<ul><li>Input Voltage: 3.3 ~ 5V, 6V Maximum<br></li>
<li>Working Current: 15uA <br></li>
<li>Working Temperature: -20 ~ 85 ℃<br></li>
<li>Output Voltage: High 3V, low 0V<br></li>
<li>Output Delay Time (High Level): About 2.3 to 3 Seconds<br></li>
<li>Detection Angle: 100 °<br></li>
<li>Detection Distance: 7 meters<br></li>
<li>Output Indicator LED (When output HIGH, it will be ON)<br></li>
<li>Pin Limit Current: 100mA<br></li>
<li>Size: 30*20mm<br></li>
<li>Weight: 4g<br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0068_19-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0068_19-2.png" width="500" height="260" srcset="/images/thumb/7/7f/Ks0068_19-2.png/750px-Ks0068_19-2.png 1.5x, /images/7/7f/Ks0068_19-2.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_23-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_23-3.png" width="500" height="239" srcset="/images/thumb/c/c5/Ks0077_23-3.png/750px-Ks0077_23-3.png 1.5x, /images/thumb/c/c5/Ks0077_23-3.png/1000px-Ks0077_23-3.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>byte sensorPin = 3;
byte indicator = 13;
void setup()
{
  pinMode(sensorPin,INPUT);
  pinMode(indicator,OUTPUT);
  Serial.begin(9600);
}

void loop()
{
  byte state = digitalRead(sensorPin);
  digitalWrite(indicator,state);
  if(state == 1)Serial.println("Somebody is in this area!");
  else if(state == 0)Serial.println("No one!");
  delay(500);
}
</pre>
<h3><span class="mw-headline" id="Project_24:_Analog_Gas_Sensor"><b>Project 24: Analog Gas Sensor</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Analog_gas.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Analog_gas.png" width="353" height="210"></a><br>
</p><p><b>Introduction:</b><br>
This analog gas sensor - MQ2 is used in gas leakage detecting equipment in both consumer electronics and industrial markets. This sensor is suitable for LPG, I-butane, propane, methane, alcohol, Hydrogen and smoke detection. It has high sensitivity and quick response. In addition, the sensitivity can be adjusted by the potentiometer. <br>
</p><p><b>Specification:</b><br>
</p>
<ul><li>Power supply: 5V<br></li>
<li>Interface type: Analog<br></li>
<li>Wide detecting scope<br></li>
<li>Quick response and high sensitivity<br></li>
<li>Simple drive circuit<br></li>
<li>Stable and long lifespan<br></li>
<li>Size: 49.7*20mm<br></li>
<li>Weight: 8g <br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_24-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_24-2.png" width="500" height="288" srcset="/images/thumb/0/03/Ks0077_24-2.png/750px-Ks0077_24-2.png 1.5x, /images/0/03/Ks0077_24-2.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_24-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_24-3.png" width="500" height="236" srcset="/images/thumb/9/91/Ks0077_24-3.png/750px-Ks0077_24-3.png 1.5x, /images/thumb/9/91/Ks0077_24-3.png/1000px-Ks0077_24-3.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>void setup()
{
  Serial.begin(9600); //Set serial baud rate to 9600 bps
}
void loop()
{int val;
val=analogRead(0);//Read Gas value from analog 0
Serial.println(val,DEC);//Print the value to serial port
delay(100);
}
</pre>
<h3><span class="mw-headline" id="Project_25:_ADXL345_Three_Axis_Acceleration_Module"><b>Project 25: ADXL345 Three Axis Acceleration Module</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-三轴加速.png" width="300" height="244" srcset="/images/thumb/f/fe/%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png/450px-%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png 1.5x, /images/f/fe/%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F.png 2x"></a><br>
</p><p><b>Introduction:</b><br>
The ADXL345 is a small, thin, low power, 3-axis MEMS accelerometer with high resolution (13-bit) measurement at up to +-16 g. Digital output data is formatted as 16-bit twos complement and is accessible through either a SPI (3-or 4-wire) or I2C digital interface.<br>
The ADXL345 is well suited to measure the static acceleration of gravity in tilt-sensing applications, as well as dynamic acceleration resulting from motion or shock. Its high resolution (4 mg/LSB) enables measurement of inclination change less than 1.0 degrees. <br>
</p><p><b>Specification:</b><br>
</p>
<ul><li>2.0-3.6VDC Supply Voltage<br></li>
<li>Ultra Low Power: 40uA in measurement mode, 0.1uA in standby@ 2.5V<br></li>
<li>Tap/Double Tap Detection<br></li>
<li>Free-Fall Detection<br></li>
<li>SPI and I2C interfaces<br></li>
<li>Size: 30*20mm<br></li>
<li>Weight: 3g <br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0068_29-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0068_29-2.png" width="500" height="295" srcset="/images/thumb/b/b5/Ks0068_29-2.png/750px-Ks0068_29-2.png 1.5x, /images/thumb/b/b5/Ks0068_29-2.png/1000px-Ks0068_29-2.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_25-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_25-3.png" width="500" height="231" srcset="/images/thumb/d/d0/Ks0077_25-3.png/750px-Ks0077_25-3.png 1.5x, /images/thumb/d/d0/Ks0077_25-3.png/1000px-Ks0077_25-3.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>/*
The circuit:
 VCC: 5V
 GND: ground
 SCL: UNO SLC
 SDA: UNO SDA
 
 This example code is in the public domain.

*/
#include &lt;Wire.h&gt;
// Registers for ADXL345
#define ADXL345_ADDRESS (0xA6 &gt;&gt; 1)  // address for device is 8 bit but shift to the
                                     // right by 1 bit to make it 7 bit because the
                                     // wire library only takes in 7 bit addresses
#define ADXL345_REGISTER_XLSB (0x32)

int accelerometer_data[3];
// void because this only tells the cip to send data to its output register
// writes data to the slave's buffer
void i2c_write(int address, byte reg, byte data) {
  // Send output register address
  Wire.beginTransmission(address);
  // Connect to device
  Wire.write(reg);
  // Send data
  Wire.write(data); //low byte
  Wire.endTransmission();
}

// void because using pointers
// microcontroller reads data from the sensor's input register
void i2c_read(int address, byte reg, int count, byte* data) {
  // Used to read the number of data received
  int i = 0;
  // Send input register address
  Wire.beginTransmission(address);
  // Connect to device
  Wire.write(reg);
  Wire.endTransmission();

  // Connect to device
  Wire.beginTransmission(address);
  // Request data from slave
  // Count stands for number of bytes to request
  Wire.requestFrom(address, count);
  while(Wire.available()) // slave may send less than requested
  {
    char c = Wire.read(); // receive a byte as character
    data[i] = c;
    i++;
  }
  Wire.endTransmission();
}

void init_adxl345() {
  byte data = 0;

  i2c_write(ADXL345_ADDRESS, 0x31, 0x0B);   // 13-bit mode  +_ 16g
  i2c_write(ADXL345_ADDRESS, 0x2D, 0x08);   // Power register

  i2c_write(ADXL345_ADDRESS, 0x1E, 0x00);   // x
  i2c_write(ADXL345_ADDRESS, 0x1F, 0x00);   // Y
  i2c_write(ADXL345_ADDRESS, 0x20, 0x05);   // Z
 
  // Check to see if it worked!
  i2c_read(ADXL345_ADDRESS, 0X00, 1, &amp;data);
  if(data==0xE5)
    Serial.println("it work Success");
  else
    Serial.println("it work Fail");
}

void read_adxl345() {
  byte bytes[6];
  memset(bytes,0,6);

  // Read 6 bytes from the ADXL345
  i2c_read(ADXL345_ADDRESS, ADXL345_REGISTER_XLSB, 6, bytes);
  // Unpack data
  for (int i=0;i&lt;3;++i) {
    accelerometer_data[i] = (int)bytes[2*i] + (((int)bytes[2*i + 1]) &lt;&lt; 8);
  }
}
// initialise and start everything
void setup() {
  Wire.begin();
  Serial.begin(9600);
  for(int i=0; i&lt;3; ++i) {
    accelerometer_data[i]  = 0;
  }
  init_adxl345();
}

void loop() {
  read_adxl345();
  Serial.print("ACCEL: ");
  Serial.print(float(accelerometer_data[0])*3.9/1000);//3.9mg/LSB scale factor in 13-bit mode
  Serial.print("\t");
  Serial.print(float(accelerometer_data[1])*3.9/1000);
  Serial.print("\t");
  Serial.print(float(accelerometer_data[2])*3.9/1000);
  Serial.print("\n");
  delay(100);
}
</pre>
<h3><span class="mw-headline" id="Project_26:_HC-SR04_Ultrasonic_Sensor"><b>Project 26: HC-SR04 Ultrasonic Sensor</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Ks0077_26-1.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/300px-Ks0077_26-1.png" width="300" height="264" srcset="/images/thumb/9/99/Ks0077_26-1.png/450px-Ks0077_26-1.png 1.5x, /images/thumb/9/99/Ks0077_26-1.png/600px-Ks0077_26-1.png 2x"></a><br>
</p><p><b>Introduction:</b><br>
The HC-SR04 Ultrasonic Sensor is a very affordable proximity/distance sensor that has been used mainly for object avoidance in various robotics projects. It essentially gives your Arduino eyes / spacial awareness and can prevent your robot from crashing or falling off a table. It has also been used in turret applications, water level sensing, and even as a parking sensor. This simple project will use the HC-SR04 sensor with an Arduino and a Processing sketch to provide a neat little interactive display on your computer screen. <br>
</p><p><b>Specification:</b><br>
</p>
<ul><li>Working Voltage: DC 5V<br></li>
<li>Working Current: 15mA<br></li>
<li>Working Frequency: 40Hz<br></li>
<li>Max Range: 4m<br></li>
<li>Min Range: 2cm<br></li>
<li>Measuring Angle: 15 degree<br></li>
<li>Trigger Input Signal: 10µS TTL pulse<br></li>
<li>Echo Output Signal Input TTL lever signal and the range in proportion<br></li>
<li>Size: 46*20.4mm<br></li>
<li>Weight: 9g <br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Pro26-wiring1.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Pro26-wiring1.png" width="500" height="300" srcset="/images/thumb/d/de/Pro26-wiring1.png/750px-Pro26-wiring1.png 1.5x, /images/thumb/d/de/Pro26-wiring1.png/1000px-Pro26-wiring1.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Pro26-wiring2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Pro26-wiring2.png" width="500" height="300" srcset="/images/thumb/2/29/Pro26-wiring2.png/750px-Pro26-wiring2.png 1.5x, /images/thumb/2/29/Pro26-wiring2.png/1000px-Pro26-wiring2.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
VCC to arduino 5v <br>
GND to arduino GND<br>
Echo to Arduino pin 7 <br>
Trig to Arduino pin 8<br>
</p>
<pre> 
#define echoPin 7 // Echo Pin
#define trigPin 8 // Trigger Pin
#define LEDPin 13 // Onboard LED
int maximumRange = 200; // Maximum range needed
int minimumRange = 0; // Minimum range needed
long duration, distance; // Duration used to calculate distance

void setup() {
 Serial.begin (9600);
 pinMode(trigPin, OUTPUT);
 pinMode(echoPin, INPUT);
 pinMode(LEDPin, OUTPUT); // Use LED indicator (if required)
}

void loop() {
/* The following trigPin/echoPin cycle is used to determine the
 distance of the nearest object by bouncing soundwaves off of it. */ 
 digitalWrite(trigPin, LOW); 
 delayMicroseconds(2); 

 digitalWrite(trigPin, HIGH);
 delayMicroseconds(10); 
 digitalWrite(trigPin, LOW);
 duration = pulseIn(echoPin, HIGH);
 
 //Calculate the distance (in cm) based on the speed of sound.
 distance = duration/58.2;
 
 if (distance &gt;= maximumRange || distance &lt;= minimumRange){
 /* Send a negative number to computer and Turn LED ON 
 to indicate "out of range" */
 Serial.println("-1");
 digitalWrite(LEDPin, HIGH); 
 }
 else {
 /* Send the distance to the computer using Serial protocol, and
 turn LED OFF to indicate successful reading. */
 Serial.println(distance);
 digitalWrite(LEDPin, LOW); 
 }
 
 //Delay 50ms before next reading.
 delay(50);
}
</pre>
<h3><span class="mw-headline" id="Project_27:_Joystick_Module"><b>Project 27: Joystick Module</b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Joystick-.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Joystick-.png" width="137" height="108"></a><br>
</p><p><b>Introduction:</b><br>
Lots of robot projects need joystick. This module provides an affordable solution. By simply connecting to two analog inputs, the robot is at your commands with X, Y control. It also has a switch that is connected to a digital pin. This joystick module can be easily connected to Arduino by IO Shield. This module is for Arduino(V5) with cable supplied. <br>
</p><p><b>Specification:</b><br>
Supply Voltage: 3.3V to 5V<br>
Interface: Analog x2, Digital x1<br>
Size: 40*28mm<br>
Weight: 12g <br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_27-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_27-2.png" width="500" height="285" srcset="/images/thumb/c/c4/Ks0077_27-2.png/750px-Ks0077_27-2.png 1.5x, /images/c/c4/Ks0077_27-2.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_27-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_27-3.png" width="500" height="258" srcset="/images/thumb/e/e4/Ks0077_27-3.png/750px-Ks0077_27-3.png 1.5x, /images/thumb/e/e4/Ks0077_27-3.png/1000px-Ks0077_27-3.png 2x"></a><br>
</p><p><br>
<b>Sample Code:</b><br>
</p>
<pre>int JoyStick_X = 0; //x
int JoyStick_Y = 1; //y
int JoyStick_Z = 3; //key
  void setup() 
{
  pinMode(JoyStick_Z, INPUT); 
  Serial.begin(9600); // 9600 bps
}
void loop() 
{
  int x,y,z;
  x=analogRead(JoyStick_X);
  y=analogRead(JoyStick_Y);
  z=digitalRead(JoyStick_Z);
  Serial.print(x ,DEC);
  Serial.print(",");
  Serial.print(y ,DEC);
  Serial.print(",");
  Serial.println(z ,DEC);
  delay(100);
}
</pre>
<h3><span class="mw-headline" id="Project_28:_5V_Relay_Module"><b>Project 28: 5V Relay Module </b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Relay.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Relay.png" width="291" height="236"></a><br>
</p><p><b>Introduction:</b><br>
This single relay module can be used in interactive projects. This module uses SONGLE 5v high-quality relay. It can also be used to control lighting, electrical and other equipment. The modular design makes it easy to expand with the Arduino board (not included). The Relay output is by a light-emitting diode. It can be controlled through digital IO port, such as solenoid valves, lamps, motors and other high current or high voltage devices. <br>
</p><p><b>Specification:</b><br>
</p>
<ul><li>Type: Digital<br></li>
<li>Rated Current: 10A (NO) 5A (NC)<br></li>
<li>Maximum switching voltage: 150VAC 24VDC<br></li>
<li>Digital interface<br></li>
<li>Control signal: TTL level<br></li>
<li>Rated load: 8A 150VAC (NO) 10A 24VDC (NO), 5A 250VAC (NO/NC) 5A 24VDC (NO/NC)<br></li>
<li>Maximum switching power: AC1200VA DC240W (NO) AC625VA DC120W (NC)<br></li>
<li>Contact action time: 10ms<br></li>
<li>Size: 40*28mm<br></li>
<li>Weight: 15g <br></li></ul>
<p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0068_36-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0068_36-2.png" width="500" height="294" srcset="/images/thumb/0/0d/Ks0068_36-2.png/750px-Ks0068_36-2.png 1.5x, /images/thumb/0/0d/Ks0068_36-2.png/1000px-Ks0068_36-2.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_28-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_28-3.png" width="500" height="256" srcset="/images/thumb/d/d3/Ks0077_28-3.png/750px-Ks0077_28-3.png 1.5x, /images/thumb/d/d3/Ks0077_28-3.png/1000px-Ks0077_28-3.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre> int Relay = 8;
  void setup()
{
  pinMode(13, OUTPUT);         //Set Pin13 as output
  digitalWrite(13, HIGH);     //Set Pin13 High
  pinMode(Relay, OUTPUT);     //Set Pin3 as output
}
void loop()
{
          digitalWrite(Relay, HIGH);   //Turn off relay
          delay(2000);
          digitalWrite(Relay, LOW);    //Turn on relay
          delay(2000);
}
</pre>
<h3><span class="mw-headline" id="Project_29:_DS3231_Clock_Module"><b>Project 29: DS3231 Clock Module </b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Clock.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Clock.png" width="364" height="291"></a><br>
</p><p><b>Introduction:</b><br>
DS3231 is equipped with integrated TCXO and crystal, which makes it a cost-effective I2C real time clock with high precision. The device carries a battery input, so even if you disconnect the main power supply, it can still maintain accurate timing. The integrated oscillator ensures the long-term accuracy of the device and reduces the number of components. DS3231 provides both commercial and industrial temperature range and supports 16 pins small-outline package (300mil). The module itself can adapt to the system of 3.3V and 5V without level switch, which is quite convenient! <br>
</p><p><b>Specification:</b><br>
</p>
<ul><li>Temperature range: -40 to +85; <br></li>
<li>Timing accuracy&nbsp;: ± 5ppm (±0.432 seconds / day)<br></li>
<li>Provide battery backup for continuous timing<br></li>
<li>Low power consumption<br></li>
<li>Device package and function compatible with DS3231<br></li>
<li>Complete clock calendar function contains seconds and minutes, hour, week, date, month, and year timing and provides leap year compensation until 2100.<br></li>
<li>Two calendar clock<br></li>
<li>Output: 1Hz and 32.768kHz<br></li>
<li>Reset output and Input Debounce of Pushbutton <br></li>
<li>High speed (400kHz), I2C serial bus<br></li>
<li>Supply voltage: +3.3V to +5.5V <br></li>
<li>Digital temperature sensor with a precision of±3℃<br></li>
<li>Working temperature: -40 ~ C to +85 ~ C <br></li>
<li>16 pins Small Outline Package (300mil)<br></li>
<li>Size: 30*20mm<br></li>
<li>Weight: 4g <br></li></ul>
<p><b>Connection for UNO R3:</b> <br>
This module adopts the IIC test method, so only need to connect ‘SDA’ to Arduino A4, ‘SCL’ to A5, ‘+’ to VCC and ‘-’ to GND as follows:<br>
<br><a href="https://wiki.keyestudio.com/File:Ks0068_35-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0068_35-2.png" width="500" height="274" srcset="/images/thumb/1/15/Ks0068_35-2.png/750px-Ks0068_35-2.png 1.5x, /images/1/15/Ks0068_35-2.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_29-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_29-3.png" width="500" height="255" srcset="/images/thumb/5/53/Ks0077_29-3.png/750px-Ks0077_29-3.png 1.5x, /images/thumb/5/53/Ks0077_29-3.png/1000px-Ks0077_29-3.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre> #include &lt;Wire.h&gt;
#include "DS3231.h"
DS3231 RTC; //Create the DS3231 object
char weekDay[][4] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
//year, month, date, hour, min, sec and week-day(starts from 0 and goes to 6)
//writing any non-existent time-data may interfere with normal operation of the RTC.
//Take care of week-day also.
DateTime dt(2011, 11, 10, 15, 18, 0, 5);//open the series port and you can check time here or make a change to the time as needed.
void setup () 
{   Serial.begin(57600);//set baud rate to 57600
    Wire.begin();
    RTC.begin();
    RTC.adjust(dt); //Adjust date-time as defined 'dt' above 
}
void loop () 
{  
 DateTime now = RTC.now(); //get the current date-time
    Serial.print(now.year(), DEC);
    Serial.print('/');
    Serial.print(now.month(), DEC);
    Serial.print('/');
    Serial.print(now.date(), DEC);
    Serial.print(' ');
    Serial.print(now.hour(), DEC);
    Serial.print(':');
    Serial.print(now.minute(), DEC);
    Serial.print(':');
    Serial.print(now.second(), DEC);
    Serial.println();
    Serial.print(weekDay[now.dayOfWeek()]);
    Serial.println();
    delay(1000);
}
</pre>
<p>Before compiling the code, you’d better put <a rel="nofollow" class="external text" href="https://www.arduino.cc/en/Main/Software">DS3231 library</a> under file into Arduino catalogue. <br>
</p><p><b>Result:</b><br>
Done uploading the code to arduino, open the serial monitor and get the following results: <br>
<br><a href="https://wiki.keyestudio.com/File:Ks0068_35-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Ks0068_35-3.png" width="443" height="542"></a><br>
</p><p><br>
</p>
<h3><span class="mw-headline" id="Project_30:_DHT11_Temperature_and_Humidity_Sensor"><b>Project 30: DHT11 Temperature and Humidity Sensor </b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:DHT11.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/DHT11.png" width="337" height="259"></a><br>
</p><p><b>Introduction:</b><br>
This DHT11 Temperature and Humidity Sensor features calibrated digital signal output with the temperature and humidity sensor complex. Its technology ensures high reliability and excellent long-term stability. A high-performance 8-bit microcontroller is connected. This sensor includes a resistive element and a sense of wet NTC temperature measuring devices. It has the advantages of excellent quality, fast response, anti-interference ability and high cost performance.<br>
Each DHT11 sensor features extremely accurate calibration data of humidity calibration chamber. The calibration coefficients stored in the OTP program memory, internal sensors detect signals in the process, and we should call these calibration coefficients. The single-wire serial interface system is integrated to make it quick and easy. Qualities of small size, low power, and 20-meter signal transmission distance make it a widely applied application and even the most demanding one. Convenient connection and special package can be provided according to your need.<br>
</p><p><b>Specification:</b><br>
Supply Voltage: +5 V<br>
Temperature Range: 0-50 °C error of ± 2 °C<br>
Humidity: 20-90% RH ± 5% RH error<br>
Interface: Digital<br>
Size: 30*20mm<br>
Weight: 4g <br>
</p><p><b>Connection for UNO R3:</b><br>
This module adopts the IIC test method, so only need to connect ‘SDA’ to Arduino A4, ‘SCL’ to A5, ‘+’ to VCC and ‘-’ to GND as follows:<br>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_30-2.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_30-2.png" width="500" height="323" srcset="/images/thumb/5/50/Ks0077_30-2.png/750px-Ks0077_30-2.png 1.5x, /images/5/50/Ks0077_30-2.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_30-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_30-3.png" width="500" height="255" srcset="/images/thumb/0/0b/Ks0077_30-3.png/750px-Ks0077_30-3.png 1.5x, /images/thumb/0/0b/Ks0077_30-3.png/1000px-Ks0077_30-3.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p><p>Please download the <a rel="nofollow" class="external text" href="https://www.arduino.cc/en/Main/Software">DHT11Lib</a> firstly. Or <a rel="nofollow" class="external text" href="https://www.arduino.cc/en/Main/Software">see the website</a>
</p>
<pre>#include &lt;dht11.h&gt;
dht11 DHT;
#define DHT11_PIN 4
  
void setup(){
  Serial.begin(9600);
  Serial.println("DHT TEST PROGRAM ");
  Serial.print("LIBRARY VERSION: ");
  Serial.println(DHT11LIB_VERSION);
  Serial.println();
  Serial.println("Type,\tstatus,\tHumidity (%),\tTemperature (C)");
}
  
void loop(){
  int chk;
  Serial.print("DHT11, \t");
  chk = DHT.read(DHT11_PIN);    // READ DATA
  switch (chk){
    case DHTLIB_OK:  
                Serial.print("OK,\t"); 
                break;
    case DHTLIB_ERROR_CHECKSUM: 
                Serial.print("Checksum error,\t"); 
                break;
    case DHTLIB_ERROR_TIMEOUT: 
                Serial.print("Time out error,\t"); 
                break;
    default: 
                Serial.print("Unknown error,\t"); 
                break;
  }
 // DISPLAT DATA
  Serial.print(DHT.humidity,1);
  Serial.print(",\t");
  Serial.println(DHT.temperature,1);
  
  delay(1000);
}
</pre>
<h3><span class="mw-headline" id="Project_31:_Soil_Humidity_Sensor"><b>Project 31: Soil Humidity Sensor </b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:Soil.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Soil.png" width="353" height="241"></a><br>
<b>Introduction:</b><br>
This is a simple soil humidity sensor aims to detect the soil humidity. If the soil is lack of water, the analog value output by the sensor will decrease, otherwise, it will increase. If you use this sensor to make an automatic watering device, it can detect whether your botany is thirsty so as to prevent it from withering when you go out. Using the sensor with Arduino controller makes your plant more comfortable and your garden smarter. <br>
The soil humidity sensor module is not as complicated as you might think. If you need to detect the soil in your project, it will be your best choice.<br>
The sensor is set with two probes inserted into the soil, then with the current go through the soil, the sensor will get resistance value by reading the current changes between the two probes and convert such resistance value into moisture content. The higher the moisture (less resistance), the higher conductivity the soil has. <br>
The surface of the sensor have undergone metallization process to prolong its service life. Insert it into the soil and then use the AD converter to read it. With the help of this sensor, the plant can remind you: I need water.<br>
</p><p><b>Specification:</b><br>
</p>
<ul><li>Power Supply Voltage: 3.3V or 5V<br></li>
<li>Working Current: ≤ 20mA<br></li>
<li>Output Voltage: 0-2.3V (When the sensor is totally immersed in water, the<br></li>
<li>voltage will be 2.3V)</li>
<li>5V power supply，the higher humidity, the higher the output voltage<br></li>
<li>Packaging&nbsp;: Electrostatic bag sealing<br></li>
<li>Sensor type: Analog output<br></li>
<li>Interface definition: Pin1- signal, pin2- GND, pin3 - VCC <br></li>
<li>Service life: About one year (gold-plated surface for enhancing conductivity and corrosion resistance )<br></li>
<li>Module size: 20X60mm <br></li></ul>
<p><b>Connection Method:</b> <br>
This module adopts the IIC test method, so only need to connect ‘SDA’ to Arduino A4, ‘SCL’ to A5, ‘+’ to VCC and ‘-’ to GND as follows:<br>
</p><p><b>Connection for UNO R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_31-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_31-3.png" width="500" height="266" srcset="/images/thumb/6/67/Ks0077_31-3.png/750px-Ks0077_31-3.png 1.5x, /images/6/67/Ks0077_31-3.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_31-4.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_31-4.png" width="500" height="262" srcset="/images/thumb/6/6d/Ks0077_31-4.png/750px-Ks0077_31-4.png 1.5x, /images/thumb/6/6d/Ks0077_31-4.png/1000px-Ks0077_31-4.png 2x"></a><br>
</p><p><b>Sample Code:</b><br>
</p>
<pre>  /*
# 0  ~300     dry soil
  # 300~700     humid soil
  # 700~950     in water
*/
 void setup(){
 Serial.begin(57600);
 }
 
void loop(){
 
  Serial.print("Moisture Sensor Value:");
  Serial.println(analogRead(0)); 
  delay(100);
}
</pre>
<h3><span class="mw-headline" id="Project_32:_RC522_RFID_Module"><b>Project 32: RC522 RFID Module </b></span></h3>
<p><br><a href="https://wiki.keyestudio.com/File:KS0077-.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/KS0077-.png" width="238" height="158"></a><br>
</p><p><b>Introduction:</b><br>
MF522-AN module adopts Philips MFRC522 original reader circuit chip design, easy to use, low cost, suitable for equipment development, development of advanced applications, the need for the user of RF card terminal design / production. It can be loaded directly into a variety of readers molds. Module uses voltage of 3.3V, through the SPI interface using simple few lines, it can be directly connected to any CPU board communication modules to guarantee stable and reliable work and reader distance.<br>
</p><p><b>Electrical Parameters:</b><br>
</p>
<ul><li>Current:13-26mA / DC 3.3V<br></li>
<li>Idle current:10-13mA / DC 3.3V<br></li>
<li>Sleep current: &lt;80uA<br></li>
<li>Peak current: &lt;30mA<br></li>
<li>Operating frequency: 13.56MHz<br></li>
<li>Supported card types: mifare1 S50,mifare1 S70, mifare UltraLight, mifare Pro, mifare Desfire<br></li>
<li>Dimensions: 40mm * 60mm<br></li>
<li>Environmental operating temperature: -20-80 degrees Celsius<br></li>
<li>Environment storage temperature: -40-85 degrees Celsius<br></li>
<li>Relative humidity: 5% -95% <br></li></ul>
<p><b>Circuit Connection:</b>
</p><p><b>Connection for UNO R3:</b><br>
This module adopts the IIC test method, so we only need to connect ‘SDA’ to Arduino A4, ‘SCL’ to A5, ‘+’ to VCC and ‘-’ to GND as follows:<br>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_32-3.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_32-3.png" width="500" height="347" srcset="/images/thumb/b/b0/Ks0077_32-3.png/750px-Ks0077_32-3.png 1.5x, /images/thumb/b/b0/Ks0077_32-3.png/1000px-Ks0077_32-3.png 2x"></a><br>
</p><p><b>Connection for 2560 R3:</b>
<br><a href="https://wiki.keyestudio.com/File:Ks0077_32-4.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/500px-Ks0077_32-4.png" width="500" height="290" srcset="/images/6/6e/Ks0077_32-4.png 1.5x"></a><br>
</p><p><br>
<b>Sample Code:</b><br>
</p>
<pre>#include &lt;SPI.h&gt;
#define	uchar	unsigned char
#define	uint	unsigned int
#define MAX_LEN 16
const int chipSelectPin = 10;//if the controller is UNO,328,168
const int NRSTPD = 5;

//MF522command word
#define PCD_IDLE              0x00               //NO action;concel current command
#define PCD_AUTHENT           0x0E               //verify key
#define PCD_RECEIVE           0x08               //receive data
#define PCD_TRANSMIT          0x04               //send data
#define PCD_TRANSCEIVE        0x0C               //receive and send data
#define PCD_RESETPHASE        0x0F               //reset
#define PCD_CALCCRC           0x03               //CRC calculation

//Mifare_One Card command word
#define PICC_REQIDL           0x26               // line-tracking area is dormant #define PICC_REQALL           0x52                     //line-tracking area is interfered
#define PICC_ANTICOLL         0x93               //Anti collision
#define PICC_SElECTTAG        0x93               //choose cards
#define PICC_AUTHENT1A        0x60               //Verify A key
#define PICC_AUTHENT1B        0x61               //Verify B key
#define PICC_READ             0x30               // Reader Module 
#define PICC_WRITE            0xA0               // letter block
#define PICC_DECREMENT        0xC0               
#define PICC_INCREMENT        0xC1               
#define PICC_RESTORE          0xC2               //Transfer data to buffer
#define PICC_TRANSFER         0xB0               //Save buffer data
#define PICC_HALT             0x50               //Dormancy


//MF522 Error code returned when communication
#define MI_OK                 0
#define MI_NOTAGERR           1
#define MI_ERR                2


//------------------MFRC522 Register---------------
//Page 0:Command and Status
#define     Reserved00            0x00    
#define     CommandReg            0x01    
#define     CommIEnReg            0x02    
#define     DivlEnReg             0x03    
#define     CommIrqReg            0x04    
#define     DivIrqReg             0x05
#define     ErrorReg              0x06    
#define     Status1Reg            0x07    
#define     Status2Reg            0x08    
#define     FIFODataReg           0x09
#define     FIFOLevelReg          0x0A
#define     WaterLevelReg         0x0B
#define     ControlReg            0x0C
#define     BitFramingReg         0x0D
#define     CollReg               0x0E
#define     Reserved01            0x0F
//Page 1:Command     
#define     Reserved10            0x10
#define     ModeReg               0x11
#define     TxModeReg             0x12
#define     RxModeReg             0x13
#define     TxControlReg          0x14
#define     TxAutoReg             0x15
#define     TxSelReg              0x16
#define     RxSelReg              0x17
#define     RxThresholdReg        0x18
#define     DemodReg              0x19
#define     Reserved11            0x1A
#define     Reserved12            0x1B
#define     MifareReg             0x1C
#define     Reserved13            0x1D
#define     Reserved14            0x1E
#define     SerialSpeedReg        0x1F
//Page 2:CFG    
#define     Reserved20            0x20  
#define     CRCResultRegM         0x21
#define     CRCResultRegL         0x22
#define     Reserved21            0x23
#define     ModWidthReg           0x24
#define     Reserved22            0x25
#define     RFCfgReg              0x26
#define     GsNReg                0x27
#define     CWGsPReg	          0x28
#define     ModGsPReg             0x29
#define     TModeReg              0x2A
#define     TPrescalerReg         0x2B
#define     TReloadRegH           0x2C
#define     TReloadRegL           0x2D
#define     TCounterValueRegH     0x2E
#define     TCounterValueRegL     0x2F
//Page 3:TestRegister     
#define     Reserved30            0x30
#define     TestSel1Reg           0x31
#define     TestSel2Reg           0x32
#define     TestPinEnReg          0x33
#define     TestPinValueReg       0x34
#define     TestBusReg            0x35
#define     AutoTestReg           0x36
#define     VersionReg            0x37
#define     AnalogTestReg         0x38
#define     TestDAC1Reg           0x39  
#define     TestDAC2Reg           0x3A   
#define     TestADCReg            0x3B   
#define     Reserved31            0x3C   
#define     Reserved32            0x3D   
#define     Reserved33            0x3E   
#define     Reserved34			  0x3F
uchar serNum[5];
uchar  writeDate[16] ={'T', 'e', 'n', 'g', ' ', 'B', 'o', 0, 0, 0, 0, 0, 0, 0, 0,0};
uchar sectorKeyA[16][16] = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                             {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                             {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                            };
 uchar sectorNewKeyA[16][16] = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                                {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xff,0x07,0x80,0x69, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                                {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xff,0x07,0x80,0x69, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                               };

void setup() {                
   Serial.begin(9600);                       // RFID reader SOUT pin connected to Serial RX pin at 2400bps 
 // start the SPI library:
  SPI.begin();
  
  pinMode(chipSelectPin,OUTPUT);             // Set digital pin 10 as OUTPUT to connect it to the RFID /ENABLE pin 
    digitalWrite(chipSelectPin, LOW);          // Activate the RFID reader
  pinMode(NRSTPD,OUTPUT);               // Set digital pin 10 , Not Reset and Power-down
    digitalWrite(NRSTPD, HIGH);

  MFRC522_Init();  
}

void loop()
{
  	uchar i,tmp;
	uchar status;
        uchar str[MAX_LEN];
        uchar RC_size;
        uchar blockAddr;	//Select the address of the operation 0～63


		// searching card, return card type
		status = MFRC522_Request(PICC_REQIDL, str);	
		if (status == MI_OK)
		{
		}

		
		status = MFRC522_Anticoll(str);
		memcpy(serNum, str, 5);
		if (status == MI_OK)
		{
                        Serial.println("The card's number is &nbsp;: ");
			Serial.print(serNum[0],BIN);
			Serial.print(serNum[1],BIN);
			Serial.print(serNum[2],BIN);
			Serial.print(serNum[3],BIN);
			Serial.print(serNum[4],BIN);
                        Serial.println(" ");
		}

		// select card, return card capacity
		RC_size = MFRC522_SelectTag(serNum);
		if (RC_size&nbsp;!= 0)
		{}
                
		// write data card
		blockAddr = 7;		// data block 7		
		status = MFRC522_Auth(PICC_AUTHENT1A, blockAddr, sectorKeyA[blockAddr/4], serNum);	// authentication
		if (status == MI_OK)
		{
			// write data
			status = MFRC522_Write(blockAddr, sectorNewKeyA[blockAddr/4]);
                        Serial.print("set the new card password, and can modify the data of the Sector: ");
                        Serial.print(blockAddr/4,DEC);
   
                        // write data
                        blockAddr = blockAddr - 3&nbsp;; 
                        status = MFRC522_Write(blockAddr, writeDate);
                        if(status == MI_OK)
                        {
                           Serial.println("OK!");
                        }
		}

		// read card
		blockAddr = 7;		// data block 7		
		status = MFRC522_Auth(PICC_AUTHENT1A, blockAddr, sectorNewKeyA[blockAddr/4], serNum);	// authentication
		if (status == MI_OK)
		{
			// read data
                        blockAddr = blockAddr - 3&nbsp;; 
                        status = MFRC522_Read(blockAddr, str);
			if (status == MI_OK)
			{
                                Serial.println("Read from the card ,the data is&nbsp;: ");
				for (i=0; i&lt;16; i++)
				{
              			      Serial.print(str[i]);
				}
                                Serial.println(" ");
			}
		}
                Serial.println(" ");
		MFRC522_Halt();			// command card to enter standby mode              
          
}

void Write_MFRC522(uchar addr, uchar val)
{
	digitalWrite(chipSelectPin, LOW);

	SPI.transfer((addr&lt;&lt;1)&amp;0x7E);	
	SPI.transfer(val);
	
	digitalWrite(chipSelectPin, HIGH);
}


uchar Read_MFRC522(uchar addr)
{
	uchar val;

	digitalWrite(chipSelectPin, LOW);

	// address format: 1XXXXXX0
	SPI.transfer(((addr&lt;&lt;1)&amp;0x7E) | 0x80);	
	val =SPI.transfer(0x00);
	
	digitalWrite(chipSelectPin, HIGH);
	
	return val;	
}


void SetBitMask(uchar reg, uchar mask)  
{
    uchar tmp;
    tmp = Read_MFRC522(reg);
    Write_MFRC522(reg, tmp | mask);  // set bit mask
}



void ClearBitMask(uchar reg, uchar mask)  
{
    uchar tmp;
    tmp = Read_MFRC522(reg);
    Write_MFRC522(reg, tmp &amp; (~mask));  // clear bit mask
} 



void AntennaOn(void)
{
	uchar temp;

	temp = Read_MFRC522(TxControlReg);
	if (!(temp &amp; 0x03))
	{
		SetBitMask(TxControlReg, 0x03);
	}
}

void AntennaOff(void)
{
	ClearBitMask(TxControlReg, 0x03);
}

void MFRC522_Reset(void)
{
    Write_MFRC522(CommandReg, PCD_RESETPHASE);
}

void MFRC522_Init(void)
{
	digitalWrite(NRSTPD,HIGH);

	MFRC522_Reset();
	 	
	//Timer: TPrescaler*TreloadVal/6.78MHz = 24ms
    Write_MFRC522(TModeReg, 0x8D);		//Tauto=1; f(Timer) = 6.78MHz/TPreScaler
    Write_MFRC522(TPrescalerReg, 0x3E);	//TModeReg[3..0] + TPrescalerReg
    Write_MFRC522(TReloadRegL, 30);           
    Write_MFRC522(TReloadRegH, 0);
	
	Write_MFRC522(TxAutoReg, 0x40);		//100%ASK
	Write_MFRC522(ModeReg, 0x3D);		//CRC initial value


	AntennaOn();		// open antenna
}
uchar MFRC522_Request(uchar reqMode, uchar *TagType)
{
	uchar status;  
	uint backBits;			// received data bits

	Write_MFRC522(BitFramingReg, 0x07);		//TxLastBists = BitFramingReg[2..0]	???
	
	TagType[0] = reqMode;
	status = MFRC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &amp;backBits);

	if ((status&nbsp;!= MI_OK) || (backBits&nbsp;!= 0x10))
	{    
		status = MI_ERR;
	}
   
	return status;
}

uchar MFRC522_ToCard(uchar command, uchar *sendData, uchar sendLen, uchar *backData, uint *backLen)
{
    uchar status = MI_ERR;
    uchar irqEn = 0x00;
    uchar waitIRq = 0x00;
    uchar lastBits;
    uchar n;
    uint i;

    switch (command)
    {
        case PCD_AUTHENT:		// card key authentication
		{
			irqEn = 0x12;
			waitIRq = 0x10;
			break;
		}
		case PCD_TRANSCEIVE:	// send data in FIFO
		{
			irqEn = 0x77;
			waitIRq = 0x30;
			break;
		}
		default:
			break;
    }
   
    Write_MFRC522(CommIEnReg, irqEn|0x80);	// Allow interrupt request
    ClearBitMask(CommIrqReg, 0x80);			// clear bits of all interrupt request
    SetBitMask(FIFOLevelReg, 0x80);			//FlushBuffer=1, FIFO initialization

    
	Write_MFRC522(CommandReg, PCD_IDLE);	//NO action; cancel current command	???

	// write data into FIFO
    for (i=0; i&lt;sendLen; i++)
    {   
		Write_MFRC522(FIFODataReg, sendData[i]);    
	}

	// execute command
	Write_MFRC522(CommandReg, command);
    if (command == PCD_TRANSCEIVE)
    {    
		SetBitMask(BitFramingReg, 0x80);		//StartSend=1,transmission of data starts  
	}   
    
	// wait for the completion of data receiving
	i = 2000;	// adjust i according to clock frequency, maximum waiting time of operating M1 is 25ms	???
    do 
    {
		//CommIrqReg[7..0]
		//Set1 TxIRq RxIRq IdleIRq HiAlerIRq LoAlertIRq ErrIRq TimerIRq
        n = Read_MFRC522(CommIrqReg);
        i--;
    }
    while ((i!=0) &amp;&amp;&nbsp;!(n&amp;0x01) &amp;&amp;&nbsp;!(n&amp;waitIRq));

    ClearBitMask(BitFramingReg, 0x80);			//StartSend=0
	
    if (i&nbsp;!= 0)
    {    
        if(!(Read_MFRC522(ErrorReg) &amp; 0x1B))	//BufferOvfl Collerr CRCErr ProtecolErr
        {
            status = MI_OK;
            if (n &amp; irqEn &amp; 0x01)
            {   
				status = MI_NOTAGERR;			//??   
			}

            if (command == PCD_TRANSCEIVE)
            {
               	n = Read_MFRC522(FIFOLevelReg);
              	lastBits = Read_MFRC522(ControlReg) &amp; 0x07;
                if (lastBits)
                {   
					*backLen = (n-1)*8 + lastBits;   
				}
                else
                {   
					*backLen = n*8;   
				}

                if (n == 0)
                {   
					n = 1;    
				}
                if (n &gt; MAX_LEN)
                {   
					n = MAX_LEN;   
				}
				
				// read data which FIFO received
                for (i=0; i&lt;n; i++)
                {   
					backData[i] = Read_MFRC522(FIFODataReg);    
				}
            }
        }
        else
        {   
			status = MI_ERR;  
		}
        
    }
	
    //SetBitMask(ControlReg,0x80);           //timer stops
    //Write_MFRC522(CommandReg, PCD_IDLE); 

    return status;
}

uchar MFRC522_Anticoll(uchar *serNum)
{
    uchar status;
    uchar i;
	uchar serNumCheck=0;
    uint unLen;
    
	Write_MFRC522(BitFramingReg, 0x00);		//TxLastBists = BitFramingReg[2..0]
 
    serNum[0] = PICC_ANTICOLL;
    serNum[1] = 0x20;
    status = MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &amp;unLen);

    if (status == MI_OK)
	{
		// verify card sequence number
		for (i=0; i&lt;4; i++)
		{   
		 	serNumCheck ^= serNum[i];
		}
		if (serNumCheck&nbsp;!= serNum[i])
		{   
			status = MI_ERR;    
		}
    }

    //SetBitMask(CollReg, 0x80);		//ValuesAfterColl=1

    return status;
} 

void CalulateCRC(uchar *pIndata, uchar len, uchar *pOutData)
{
    uchar i, n;

    ClearBitMask(DivIrqReg, 0x04);			//CRCIrq = 0
    SetBitMask(FIFOLevelReg, 0x80);			// clear FIFO pointer
    //Write_MFRC522(CommandReg, PCD_IDLE);

	// write data into FIFO	
    for (i=0; i&lt;len; i++)
    {   
		Write_MFRC522(FIFODataReg, *(pIndata+i));   
	}
    Write_MFRC522(CommandReg, PCD_CALCCRC);

	// wait for the completion of CRC calculation
    i = 0xFF;
    do 
    {
        n = Read_MFRC522(DivIrqReg);
        i--;
    }
    while ((i!=0) &amp;&amp;&nbsp;!(n&amp;0x04));			//CRCIrq = 1

	// read CRC calculation result
    pOutData[0] = Read_MFRC522(CRCResultRegL);
    pOutData[1] = Read_MFRC522(CRCResultRegM);
}

uchar MFRC522_SelectTag(uchar *serNum)
{
    uchar i;
	uchar status;
	uchar size;
    uint recvBits;
    uchar buffer[9]; 

	//ClearBitMask(Status2Reg, 0x08);			//MFCrypto1On=0

    buffer[0] = PICC_SElECTTAG;
    buffer[1] = 0x70;
    for (i=0; i&lt;5; i++)
    {
    	buffer[i+2] = *(serNum+i);
    }
	CalulateCRC(buffer, 7, &amp;buffer[7]);		//??
    status = MFRC522_ToCard(PCD_TRANSCEIVE, buffer, 9, buffer, &amp;recvBits);
    
    if ((status == MI_OK) &amp;&amp; (recvBits == 0x18))
    {   
		size = buffer[0]; 
	}
    else
    {   
		size = 0;    
	}

    return size;
}

uchar MFRC522_Auth(uchar authMode, uchar BlockAddr, uchar *Sectorkey, uchar *serNum)
{
    uchar status;
    uint recvBits;
    uchar i;
	uchar buff[12]; 

	// Verification commands + block address + sector password + card sequence number
    buff[0] = authMode;
    buff[1] = BlockAddr;
    for (i=0; i&lt;6; i++)
    {    
		buff[i+2] = *(Sectorkey+i);   
	}
    for (i=0; i&lt;4; i++)
    {    
		buff[i+8] = *(serNum+i);   
	}
    status = MFRC522_ToCard(PCD_AUTHENT, buff, 12, buff, &amp;recvBits);

    if ((status&nbsp;!= MI_OK) || (!(Read_MFRC522(Status2Reg) &amp; 0x08)))
    {   
		status = MI_ERR;   
	}
    
    return status;
}

uchar MFRC522_Read(uchar blockAddr, uchar *recvData)
{
    uchar status;
    uint unLen;

    recvData[0] = PICC_READ;
    recvData[1] = blockAddr;
    CalulateCRC(recvData,2, &amp;recvData[2]);
    status = MFRC522_ToCard(PCD_TRANSCEIVE, recvData, 4, recvData, &amp;unLen);

    if ((status&nbsp;!= MI_OK) || (unLen&nbsp;!= 0x90))
    {
        status = MI_ERR;
    }
    
    return status;
}

uchar MFRC522_Write(uchar blockAddr, uchar *writeData)
{
    uchar status;
    uint recvBits;
    uchar i;
	uchar buff[18]; 
    
    buff[0] = PICC_WRITE;
    buff[1] = blockAddr;
    CalulateCRC(buff, 2, &amp;buff[2]);
    status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 4, buff, &amp;recvBits);

    if ((status&nbsp;!= MI_OK) || (recvBits&nbsp;!= 4) || ((buff[0] &amp; 0x0F)&nbsp;!= 0x0A))
    {   
		status = MI_ERR;   
	}
        
    if (status == MI_OK)
    {
        for (i=0; i&lt;16; i++)		// write 16Byte data into FIFO
        {    
        	buff[i] = *(writeData+i);   
        }
        CalulateCRC(buff, 16, &amp;buff[16]);
        status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 18, buff, &amp;recvBits);
        
		if ((status&nbsp;!= MI_OK) || (recvBits&nbsp;!= 4) || ((buff[0] &amp; 0x0F)&nbsp;!= 0x0A))
        {   
			status = MI_ERR;   
		}
    }
    
    return status;
}

void MFRC522_Halt(void)
{
	uchar status;
    uint unLen;
    uchar buff[4]; 

    buff[0] = PICC_HALT;
    buff[1] = 0;
    CalulateCRC(buff, 2, &amp;buff[2]);
 
    status = MFRC522_ToCard(PCD_TRANSCEIVE, buff, 4, buff,&amp;unLen);
}
</pre>
<p><b>Result:</b><br>
In this experiment, when the IC card approaches, RFID module will write data to the IC card and read the card’s data, you can see it shown on the monitor window.
<br><a href="https://wiki.keyestudio.com/File:Ks0077_32-5.png" class="image" title="thumb"><img alt="thumb" src="./keyestudio_wiki_files/Ks0077_32-5.png" width="414" height="487"></a><br>
</p><p><b>Notes:</b> if you want to use MEGA 2560 R3, please in the code change <br>
<b>const int chipSelectPin = 10;//if the controller is UNO,328,168</b><br>
into <br>
<b>const int chipSelectPin = 53;//if the controller is MEGA 2560</b> <br>
</p>
<h2><span class="mw-headline" id="Resources"><b>Resources</b></span></h2>
<p><b>Video:</b> <br>
<a rel="nofollow" class="external free" href="http://video.keyestudio.com/KS0077/">http://video.keyestudio.com/KS0077/</a>
</p><p><b>PDF:</b> <br>
<a rel="nofollow" class="external free" href="https://drive.google.com/open?id=1-lBWj4-JcaW_1a5FHhqCnELal4Gxy0eI">https://drive.google.com/open?id=1-lBWj4-JcaW_1a5FHhqCnELal4Gxy0eI</a>
</p><p><b>Download the code libraries of all projects:</b> <br>
<a rel="nofollow" class="external free" href="https://drive.google.com/open?id=14edhgrpuCcXtWTb_VLQh9-gU3B4hXSTg">https://drive.google.com/open?id=14edhgrpuCcXtWTb_VLQh9-gU3B4hXSTg</a>
</p>
<h2><span class="mw-headline" id="Buy_From"><b>Buy From</b></span></h2>
<p>ks0077: <a rel="nofollow" class="external free" href="http://www.keyestudio.com/keyestudio-super-learning-kit-for-arduino-no-board.html">http://www.keyestudio.com/keyestudio-super-learning-kit-for-arduino-no-board.html</a>
</p><p>ks0078: <a rel="nofollow" class="external free" href="http://www.keyestudio.com/keyestudio-super-learning-kit-for-arduino-with-uno-r3.html">http://www.keyestudio.com/keyestudio-super-learning-kit-for-arduino-with-uno-r3.html</a>
</p><p>ks0079: <a rel="nofollow" class="external free" href="http://www.keyestudio.com/keyestudio-super-learning-kit-for-arduino-with-2560-r3.html">http://www.keyestudio.com/keyestudio-super-learning-kit-for-arduino-with-2560-r3.html</a>
</p>


</div>

</div> <div class="printfooter">
Retrieved from "<a dir="ltr" href="https://wiki.keyestudio.com/index.php?title=Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;oldid=15016">http://wiki.keyestudio.com/index.php?title=Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;oldid=15016</a>" </div>
<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://wiki.keyestudio.com/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://wiki.keyestudio.com/index.php?title=Category:Starter_Kit&amp;action=edit&amp;redlink=1" class="new" title="Category:Starter Kit (page does not exist)">Starter Kit</a></li></ul></div></div> <div class="visualClear"></div>
</div>
</div>
<div id="mw-navigation">
<h2>Navigation menu</h2>
<div id="mw-head">
<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
<h3 id="p-personal-label">Personal tools</h3>
<ul>
<li id="pt-login"><a href="https://wiki.keyestudio.com/index.php?title=Special:UserLogin&amp;returnto=Ks0077%2878%2C+79%29+keyestudio+Super+Learning+Kit+for+Arduino" title="You are encouraged to log in; however, it is not mandatory [alt-shift-o]" accesskey="o">Log in</a></li> </ul>
</div>
<div id="left-navigation">
<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
<h3 id="p-namespaces-label">Namespaces</h3>
<ul>
<li id="ca-nstab-main" class="selected"><span><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino" title="View the content page [alt-shift-c]" accesskey="c">Page</a></span></li>
<li id="ca-talk" class="new"><span><a href="https://wiki.keyestudio.com/index.php?title=Talk:Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;action=edit&amp;redlink=1" title="Discussion about the content page [alt-shift-t]" accesskey="t" rel="discussion">Discussion</a></span></li>
</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
<h3 id="p-variants-label" tabindex="0">
<span>Variants</span><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#" tabindex="-1"></a>
</h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
</div>
<div id="right-navigation">
<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
<h3 id="p-views-label">Views</h3>
<ul>
<li id="ca-view" class="selected"><span><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino">Read</a></span></li>
<li id="ca-viewsource"><span><a href="https://wiki.keyestudio.com/index.php?title=Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;action=edit" title="This page is protected.
You can view its source [alt-shift-e]" accesskey="e">View source</a></span></li>
<li id="ca-history" class="collapsible"><span><a href="https://wiki.keyestudio.com/index.php?title=Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;action=history" title="Past revisions of this page [alt-shift-h]" accesskey="h">View history</a></span></li>
</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label" style="">
<h3 id="p-cactions-label" tabindex="0"><span>More</span><a href="https://wiki.keyestudio.com/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino#" tabindex="-1"></a></h3>
<div class="menu">
<ul>
</ul>
</div>
</div>
<div id="p-search" role="search">
<h3>
<label for="searchInput">Search</label>
</h3>
<form action="https://wiki.keyestudio.com/index.php" id="searchform">
<div id="simpleSearch">
<input type="search" name="search" placeholder="Search Keyestudio Wiki" title="Search Keyestudio Wiki [alt-shift-f]" accesskey="f" id="searchInput" tabindex="1" autocomplete="off"><input type="hidden" value="Special:Search" name="title"><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"> </div>
</form>
</div>
</div>
</div>
<div id="mw-panel">
<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="https://wiki.keyestudio.com/Main_Page" title="Visit the main page"></a></div>
<div class="portal" role="navigation" id="p-name_of_heading" aria-labelledby="p-name_of_heading-label">
<h3 id="p-name_of_heading-label">name of heading</h3>
<div class="body">
<ul>
<li><a href="https://www.keyestudio.com/">keyestudio</a></li> </ul>
</div>
</div>
<div class="portal" role="navigation" id="p-Official_Website" aria-labelledby="p-Official_Website-label">
<h3 id="p-Official_Website-label">Official Website</h3>
<div class="body">
<ul>
</ul>
</div>
</div>
<div class="portal" role="navigation" id="p-Navigation" aria-labelledby="p-Navigation-label">
<h3 id="p-Navigation-label">Navigation</h3>
<div class="body">
<ul>
<li id="n-mainpage-description"><a href="https://wiki.keyestudio.com/Main_Page" title="Visit the main page [alt-shift-z]" accesskey="z">Main page</a></li><li id="n-randompage"><a href="https://wiki.keyestudio.com/Special:Random" title="Load a random page [alt-shift-x]" accesskey="x">Random page</a></li><li id="n-recentchanges"><a href="https://wiki.keyestudio.com/Special:RecentChanges" title="A list of recent changes in the wiki [alt-shift-r]" accesskey="r">Recent changes</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li> </ul>
</div>
</div>
<div class="portal" role="navigation" id="p-Category" aria-labelledby="p-Category-label">
<h3 id="p-Category-label">Category</h3>
<div class="body">
<ul>
<li id="n-Arduino-Board"><a href="https://wiki.keyestudio.com/Category:Arduino_Board">Arduino Board</a></li><li id="n-Shield"><a href="https://wiki.keyestudio.com/Category:Shield">Shield</a></li><li id="n-Starter-Kit"><a href="https://wiki.keyestudio.com/Category:Starter_Kit">Starter Kit</a></li><li id="n-Smart-Car"><a href="https://wiki.keyestudio.com/Category:Smart_Car">Smart Car</a></li><li id="n-Sensor"><a href="https://wiki.keyestudio.com/Category:Sensor">Sensor</a></li><li id="n-3D-Printer"><a href="https://wiki.keyestudio.com/Category:3D_Printer">3D Printer</a></li><li id="n-EASY-Plug"><a href="https://wiki.keyestudio.com/Category:EASY_Plug">EASY Plug</a></li><li id="n-Module"><a href="https://wiki.keyestudio.com/Category:Module">Module</a></li><li id="n-Raspberry-Pi"><a href="https://wiki.keyestudio.com/Category:Raspberry_Pi">Raspberry Pi</a></li><li id="n-Micro:bit"><a href="https://wiki.keyestudio.com/Category:Micro:bit">Micro:bit</a></li><li id="n-Accessories"><a href="https://wiki.keyestudio.com/Category:Accessories">Accessories</a></li><li id="n-TroubleShooting"><a href="https://wiki.keyestudio.com/Category:TroubleShooting">TroubleShooting</a></li> </ul>
</div>
</div>
<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
<h3 id="p-tb-label">Tools</h3>
<div class="body">
<ul>
<li id="t-whatlinkshere"><a href="https://wiki.keyestudio.com/Special:WhatLinksHere/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino" title="A list of all wiki pages that link here [alt-shift-j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="https://wiki.keyestudio.com/Special:RecentChangesLinked/Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino" rel="nofollow" title="Recent changes in pages linked from this page [alt-shift-k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="https://wiki.keyestudio.com/Special:SpecialPages" title="A list of all special pages [alt-shift-q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://wiki.keyestudio.com/index.php?title=Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;printable=yes" rel="alternate" title="Printable version of this page [alt-shift-p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://wiki.keyestudio.com/index.php?title=Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;oldid=15016" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://wiki.keyestudio.com/index.php?title=Ks0077(78,_79)_keyestudio_Super_Learning_Kit_for_Arduino&amp;action=info" title="More information about this page">Page information</a></li> </ul>
</div>
</div>
</div>
</div>
<div id="footer" role="contentinfo">
<ul id="footer-info">
<li id="footer-info-lastmod"> This page was last edited on 14 February 2019, at 11:59.</li>
</ul>
<ul id="footer-places">
<li id="footer-places-privacy"><a href="https://wiki.keyestudio.com/Keyestudio_Wiki:Privacy_policy" title="Keyestudio Wiki:Privacy policy">Privacy policy</a></li>
<li id="footer-places-about"><a href="https://wiki.keyestudio.com/Keyestudio_Wiki:About" title="Keyestudio Wiki:About">About Keyestudio Wiki</a></li>
<li id="footer-places-disclaimer"><a href="https://wiki.keyestudio.com/Keyestudio_Wiki:General_disclaimer" title="Keyestudio Wiki:General disclaimer">Disclaimers</a></li>
</ul>
<ul id="footer-icons" class="noprint">
<li id="footer-poweredbyico">
<a href="https://www.mediawiki.org/"><img src="./keyestudio_wiki_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"></a> </li>
</ul>
<div style="clear:both"></div>
</div>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.512","walltime":"1.250","ppvisitednodes":{"value":460,"limit":1000000},"ppgeneratednodes":{"value":840,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":51857,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20190218043916","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":65});});</script>


<div class="suggestions" style="display: none; font-size: 13px;"><div class="suggestions-results"></div><div class="suggestions-special"></div></div></body></html>